// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lib/messages.proto

package lib // import "github.com/FuzzyMonkeyCo/monkey/lib"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ExecKind int32

const (
	ExecKind_UNKNOWN         ExecKind = 0
	ExecKind_start           ExecKind = 1
	ExecKind_reset           ExecKind = 2
	ExecKind_stop            ExecKind = 3
	ExecKind_stop_then_start ExecKind = 4
)

var ExecKind_name = map[int32]string{
	0: "UNKNOWN",
	1: "start",
	2: "reset",
	3: "stop",
	4: "stop_then_start",
}
var ExecKind_value = map[string]int32{
	"UNKNOWN":         0,
	"start":           1,
	"reset":           2,
	"stop":            3,
	"stop_then_start": 4,
}

func (x ExecKind) String() string {
	return proto.EnumName(ExecKind_name, int32(x))
}
func (ExecKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{0}
}

type RepError_Culprit int32

const (
	RepError_UNKNOWN RepError_Culprit = 0
	RepError_client  RepError_Culprit = 1
	RepError_server  RepError_Culprit = 2
)

var RepError_Culprit_name = map[int32]string{
	0: "UNKNOWN",
	1: "client",
	2: "server",
}
var RepError_Culprit_value = map[string]int32{
	"UNKNOWN": 0,
	"client":  1,
	"server":  2,
}

func (x RepError_Culprit) String() string {
	return proto.EnumName(RepError_Culprit_name, int32(x))
}
func (RepError_Culprit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{1, 0}
}

type UserCfg_Kind int32

const (
	UserCfg_UNKNOWN   UserCfg_Kind = 0
	UserCfg_OpenAPIv3 UserCfg_Kind = 1
)

var UserCfg_Kind_name = map[int32]string{
	0: "UNKNOWN",
	1: "OpenAPIv3",
}
var UserCfg_Kind_value = map[string]int32{
	"UNKNOWN":   0,
	"OpenAPIv3": 1,
}

func (x UserCfg_Kind) String() string {
	return proto.EnumName(UserCfg_Kind_name, int32(x))
}
func (UserCfg_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{11, 0}
}

type EndpointJSON_Method int32

const (
	EndpointJSON_UNKNOWN EndpointJSON_Method = 0
	EndpointJSON_GET     EndpointJSON_Method = 1
	EndpointJSON_HEAD    EndpointJSON_Method = 2
	EndpointJSON_POST    EndpointJSON_Method = 3
	EndpointJSON_PUT     EndpointJSON_Method = 4
	EndpointJSON_PATCH   EndpointJSON_Method = 5
	EndpointJSON_DELETE  EndpointJSON_Method = 6
	EndpointJSON_CONNECT EndpointJSON_Method = 7
	EndpointJSON_OPTIONS EndpointJSON_Method = 8
	EndpointJSON_TRACE   EndpointJSON_Method = 9
)

var EndpointJSON_Method_name = map[int32]string{
	0: "UNKNOWN",
	1: "GET",
	2: "HEAD",
	3: "POST",
	4: "PUT",
	5: "PATCH",
	6: "DELETE",
	7: "CONNECT",
	8: "OPTIONS",
	9: "TRACE",
}
var EndpointJSON_Method_value = map[string]int32{
	"UNKNOWN": 0,
	"GET":     1,
	"HEAD":    2,
	"POST":    3,
	"PUT":     4,
	"PATCH":   5,
	"DELETE":  6,
	"CONNECT": 7,
	"OPTIONS": 8,
	"TRACE":   9,
}

func (x EndpointJSON_Method) String() string {
	return proto.EnumName(EndpointJSON_Method_name, int32(x))
}
func (EndpointJSON_Method) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{17, 0}
}

type ParamJSON_Kind int32

const (
	ParamJSON_UNKNOWN ParamJSON_Kind = 0
	ParamJSON_body    ParamJSON_Kind = 1
	ParamJSON_path    ParamJSON_Kind = 2
	ParamJSON_query   ParamJSON_Kind = 3
	ParamJSON_header  ParamJSON_Kind = 4
	ParamJSON_cookie  ParamJSON_Kind = 5
)

var ParamJSON_Kind_name = map[int32]string{
	0: "UNKNOWN",
	1: "body",
	2: "path",
	3: "query",
	4: "header",
	5: "cookie",
}
var ParamJSON_Kind_value = map[string]int32{
	"UNKNOWN": 0,
	"body":    1,
	"path":    2,
	"query":   3,
	"header":  4,
	"cookie":  5,
}

func (x ParamJSON_Kind) String() string {
	return proto.EnumName(ParamJSON_Kind_name, int32(x))
}
func (ParamJSON_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{18, 0}
}

type Schema_JSON_Type int32

const (
	Schema_JSON_UNKNOWN Schema_JSON_Type = 0
	Schema_JSON_any     Schema_JSON_Type = 1
	Schema_JSON_null    Schema_JSON_Type = 2
	Schema_JSON_boolean Schema_JSON_Type = 3
	Schema_JSON_integer Schema_JSON_Type = 4
	Schema_JSON_number  Schema_JSON_Type = 5
	Schema_JSON_array   Schema_JSON_Type = 6
	Schema_JSON_string  Schema_JSON_Type = 7
	Schema_JSON_object  Schema_JSON_Type = 8
)

var Schema_JSON_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "any",
	2: "null",
	3: "boolean",
	4: "integer",
	5: "number",
	6: "array",
	7: "string",
	8: "object",
}
var Schema_JSON_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"any":     1,
	"null":    2,
	"boolean": 3,
	"integer": 4,
	"number":  5,
	"array":   6,
	"string":  7,
	"object":  8,
}

func (x Schema_JSON_Type) String() string {
	return proto.EnumName(Schema_JSON_Type_name, int32(x))
}
func (Schema_JSON_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{20, 0, 0}
}

// type: string
type Schema_JSON_Format int32

const (
	Schema_JSON_NONE      Schema_JSON_Format = 0
	Schema_JSON_date_time Schema_JSON_Format = 1
	Schema_JSON_date      Schema_JSON_Format = 2
	// time = 3;
	Schema_JSON_email Schema_JSON_Format = 4
	// idn-email = 5;
	Schema_JSON_hostname Schema_JSON_Format = 6
	// idn_hostname = 7;
	Schema_JSON_ipv4          Schema_JSON_Format = 8
	Schema_JSON_ipv6          Schema_JSON_Format = 9
	Schema_JSON_uri           Schema_JSON_Format = 10
	Schema_JSON_uri_reference Schema_JSON_Format = 11
	// iri = 12;
	// iri_reference = 13;
	// uri_template = 14;
	// json_pointer = 15;
	// relative_json_pointer = 16;
	Schema_JSON_regex    Schema_JSON_Format = 17
	Schema_JSON_int32    Schema_JSON_Format = 18
	Schema_JSON_int64    Schema_JSON_Format = 19
	Schema_JSON_float    Schema_JSON_Format = 20
	Schema_JSON_double   Schema_JSON_Format = 21
	Schema_JSON_byte     Schema_JSON_Format = 22
	Schema_JSON_binary   Schema_JSON_Format = 23
	Schema_JSON_password Schema_JSON_Format = 24
)

var Schema_JSON_Format_name = map[int32]string{
	0:  "NONE",
	1:  "date_time",
	2:  "date",
	4:  "email",
	6:  "hostname",
	8:  "ipv4",
	9:  "ipv6",
	10: "uri",
	11: "uri_reference",
	17: "regex",
	18: "int32",
	19: "int64",
	20: "float",
	21: "double",
	22: "byte",
	23: "binary",
	24: "password",
}
var Schema_JSON_Format_value = map[string]int32{
	"NONE":          0,
	"date_time":     1,
	"date":          2,
	"email":         4,
	"hostname":      6,
	"ipv4":          8,
	"ipv6":          9,
	"uri":           10,
	"uri_reference": 11,
	"regex":         17,
	"int32":         18,
	"int64":         19,
	"float":         20,
	"double":        21,
	"byte":          22,
	"binary":        23,
	"password":      24,
}

func (x Schema_JSON_Format) String() string {
	return proto.EnumName(Schema_JSON_Format_name, int32(x))
}
func (Schema_JSON_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{20, 0, 1}
}

type Msg struct {
	Ts uint64 `protobuf:"varint,1,opt,name=ts,proto3" json:"ts,omitempty"`
	// Types that are valid to be assigned to Msg:
	//	*Msg_Error
	//	*Msg_Fuzz
	//	*Msg_FuzzProgress
	//	*Msg_Metrics
	//	*Msg_DoCall
	//	*Msg_CallDone
	//	*Msg_ValidateProgress
	//	*Msg_CallResult
	//	*Msg_DoReset
	//	*Msg_ResetProgress
	Msg                  isMsg_Msg `protobuf_oneof:"msg"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Msg) Reset()         { *m = Msg{} }
func (m *Msg) String() string { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()    {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{0}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(dst, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

type isMsg_Msg interface {
	isMsg_Msg()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Msg_Error struct {
	Error *RepError `protobuf:"bytes,2,opt,name=error,oneof"`
}
type Msg_Fuzz struct {
	Fuzz *DoFuzz `protobuf:"bytes,3,opt,name=fuzz,oneof"`
}
type Msg_FuzzProgress struct {
	FuzzProgress *FuzzProgress `protobuf:"bytes,4,opt,name=fuzz_progress,json=fuzzProgress,oneof"`
}
type Msg_Metrics struct {
	Metrics *SUTMetrics `protobuf:"bytes,5,opt,name=metrics,oneof"`
}
type Msg_DoCall struct {
	DoCall *ReqDoCall `protobuf:"bytes,6,opt,name=do_call,json=doCall,oneof"`
}
type Msg_CallDone struct {
	CallDone *RepCallDone `protobuf:"bytes,7,opt,name=call_done,json=callDone,oneof"`
}
type Msg_ValidateProgress struct {
	ValidateProgress *RepValidateProgress `protobuf:"bytes,8,opt,name=validate_progress,json=validateProgress,oneof"`
}
type Msg_CallResult struct {
	CallResult *RepCallResult `protobuf:"bytes,9,opt,name=call_result,json=callResult,oneof"`
}
type Msg_DoReset struct {
	DoReset *ReqDoReset `protobuf:"bytes,10,opt,name=do_reset,json=doReset,oneof"`
}
type Msg_ResetProgress struct {
	ResetProgress *RepResetProgress `protobuf:"bytes,11,opt,name=reset_progress,json=resetProgress,oneof"`
}

func (*Msg_Error) isMsg_Msg()            {}
func (*Msg_Fuzz) isMsg_Msg()             {}
func (*Msg_FuzzProgress) isMsg_Msg()     {}
func (*Msg_Metrics) isMsg_Msg()          {}
func (*Msg_DoCall) isMsg_Msg()           {}
func (*Msg_CallDone) isMsg_Msg()         {}
func (*Msg_ValidateProgress) isMsg_Msg() {}
func (*Msg_CallResult) isMsg_Msg()       {}
func (*Msg_DoReset) isMsg_Msg()          {}
func (*Msg_ResetProgress) isMsg_Msg()    {}

func (m *Msg) GetMsg() isMsg_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *Msg) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Msg) GetError() *RepError {
	if x, ok := m.GetMsg().(*Msg_Error); ok {
		return x.Error
	}
	return nil
}

func (m *Msg) GetFuzz() *DoFuzz {
	if x, ok := m.GetMsg().(*Msg_Fuzz); ok {
		return x.Fuzz
	}
	return nil
}

func (m *Msg) GetFuzzProgress() *FuzzProgress {
	if x, ok := m.GetMsg().(*Msg_FuzzProgress); ok {
		return x.FuzzProgress
	}
	return nil
}

func (m *Msg) GetMetrics() *SUTMetrics {
	if x, ok := m.GetMsg().(*Msg_Metrics); ok {
		return x.Metrics
	}
	return nil
}

func (m *Msg) GetDoCall() *ReqDoCall {
	if x, ok := m.GetMsg().(*Msg_DoCall); ok {
		return x.DoCall
	}
	return nil
}

func (m *Msg) GetCallDone() *RepCallDone {
	if x, ok := m.GetMsg().(*Msg_CallDone); ok {
		return x.CallDone
	}
	return nil
}

func (m *Msg) GetValidateProgress() *RepValidateProgress {
	if x, ok := m.GetMsg().(*Msg_ValidateProgress); ok {
		return x.ValidateProgress
	}
	return nil
}

func (m *Msg) GetCallResult() *RepCallResult {
	if x, ok := m.GetMsg().(*Msg_CallResult); ok {
		return x.CallResult
	}
	return nil
}

func (m *Msg) GetDoReset() *ReqDoReset {
	if x, ok := m.GetMsg().(*Msg_DoReset); ok {
		return x.DoReset
	}
	return nil
}

func (m *Msg) GetResetProgress() *RepResetProgress {
	if x, ok := m.GetMsg().(*Msg_ResetProgress); ok {
		return x.ResetProgress
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Msg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Msg_OneofMarshaler, _Msg_OneofUnmarshaler, _Msg_OneofSizer, []interface{}{
		(*Msg_Error)(nil),
		(*Msg_Fuzz)(nil),
		(*Msg_FuzzProgress)(nil),
		(*Msg_Metrics)(nil),
		(*Msg_DoCall)(nil),
		(*Msg_CallDone)(nil),
		(*Msg_ValidateProgress)(nil),
		(*Msg_CallResult)(nil),
		(*Msg_DoReset)(nil),
		(*Msg_ResetProgress)(nil),
	}
}

func _Msg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Msg)
	// msg
	switch x := m.Msg.(type) {
	case *Msg_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *Msg_Fuzz:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fuzz); err != nil {
			return err
		}
	case *Msg_FuzzProgress:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FuzzProgress); err != nil {
			return err
		}
	case *Msg_Metrics:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metrics); err != nil {
			return err
		}
	case *Msg_DoCall:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DoCall); err != nil {
			return err
		}
	case *Msg_CallDone:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CallDone); err != nil {
			return err
		}
	case *Msg_ValidateProgress:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ValidateProgress); err != nil {
			return err
		}
	case *Msg_CallResult:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CallResult); err != nil {
			return err
		}
	case *Msg_DoReset:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DoReset); err != nil {
			return err
		}
	case *Msg_ResetProgress:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResetProgress); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Msg.Msg has unexpected type %T", x)
	}
	return nil
}

func _Msg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Msg)
	switch tag {
	case 2: // msg.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepError)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_Error{msg}
		return true, err
	case 3: // msg.fuzz
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DoFuzz)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_Fuzz{msg}
		return true, err
	case 4: // msg.fuzz_progress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FuzzProgress)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_FuzzProgress{msg}
		return true, err
	case 5: // msg.metrics
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SUTMetrics)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_Metrics{msg}
		return true, err
	case 6: // msg.do_call
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReqDoCall)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_DoCall{msg}
		return true, err
	case 7: // msg.call_done
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepCallDone)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_CallDone{msg}
		return true, err
	case 8: // msg.validate_progress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepValidateProgress)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_ValidateProgress{msg}
		return true, err
	case 9: // msg.call_result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepCallResult)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_CallResult{msg}
		return true, err
	case 10: // msg.do_reset
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReqDoReset)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_DoReset{msg}
		return true, err
	case 11: // msg.reset_progress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepResetProgress)
		err := b.DecodeMessage(msg)
		m.Msg = &Msg_ResetProgress{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Msg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Msg)
	// msg
	switch x := m.Msg.(type) {
	case *Msg_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_Fuzz:
		s := proto.Size(x.Fuzz)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_FuzzProgress:
		s := proto.Size(x.FuzzProgress)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_Metrics:
		s := proto.Size(x.Metrics)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_DoCall:
		s := proto.Size(x.DoCall)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_CallDone:
		s := proto.Size(x.CallDone)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_ValidateProgress:
		s := proto.Size(x.ValidateProgress)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_CallResult:
		s := proto.Size(x.CallResult)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_DoReset:
		s := proto.Size(x.DoReset)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Msg_ResetProgress:
		s := proto.Size(x.ResetProgress)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RepError struct {
	Culprit              RepError_Culprit `protobuf:"varint,1,opt,name=culprit,proto3,enum=lib.RepError_Culprit" json:"culprit,omitempty"`
	Reason               string           `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RepError) Reset()         { *m = RepError{} }
func (m *RepError) String() string { return proto.CompactTextString(m) }
func (*RepError) ProtoMessage()    {}
func (*RepError) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{1}
}
func (m *RepError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepError.Merge(dst, src)
}
func (m *RepError) XXX_Size() int {
	return m.Size()
}
func (m *RepError) XXX_DiscardUnknown() {
	xxx_messageInfo_RepError.DiscardUnknown(m)
}

var xxx_messageInfo_RepError proto.InternalMessageInfo

func (m *RepError) GetCulprit() RepError_Culprit {
	if m != nil {
		return m.Culprit
	}
	return RepError_UNKNOWN
}

func (m *RepError) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type DoFuzz struct {
	Cfg                  *UserCfg `protobuf:"bytes,1,opt,name=cfg" json:"cfg,omitempty"`
	Spec                 *SpecIR  `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DoFuzz) Reset()         { *m = DoFuzz{} }
func (m *DoFuzz) String() string { return proto.CompactTextString(m) }
func (*DoFuzz) ProtoMessage()    {}
func (*DoFuzz) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{2}
}
func (m *DoFuzz) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoFuzz) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoFuzz.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DoFuzz) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoFuzz.Merge(dst, src)
}
func (m *DoFuzz) XXX_Size() int {
	return m.Size()
}
func (m *DoFuzz) XXX_DiscardUnknown() {
	xxx_messageInfo_DoFuzz.DiscardUnknown(m)
}

var xxx_messageInfo_DoFuzz proto.InternalMessageInfo

func (m *DoFuzz) GetCfg() *UserCfg {
	if m != nil {
		return m.Cfg
	}
	return nil
}

func (m *DoFuzz) GetSpec() *SpecIR {
	if m != nil {
		return m.Spec
	}
	return nil
}

type FuzzProgress struct {
	Failure              bool     `protobuf:"varint,1,opt,name=failure,proto3" json:"failure,omitempty"`
	Success              bool     `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	LastCallFailure      bool     `protobuf:"varint,3,opt,name=last_call_failure,json=lastCallFailure,proto3" json:"last_call_failure,omitempty"`
	LastCallSuccess      bool     `protobuf:"varint,4,opt,name=last_call_success,json=lastCallSuccess,proto3" json:"last_call_success,omitempty"`
	LastCheckFailure     bool     `protobuf:"varint,5,opt,name=last_check_failure,json=lastCheckFailure,proto3" json:"last_check_failure,omitempty"`
	LastCheckSuccess     bool     `protobuf:"varint,6,opt,name=last_check_success,json=lastCheckSuccess,proto3" json:"last_check_success,omitempty"`
	Shrinking            bool     `protobuf:"varint,7,opt,name=shrinking,proto3" json:"shrinking,omitempty"`
	TotalTestsCount      uint32   `protobuf:"varint,8,opt,name=total_tests_count,json=totalTestsCount,proto3" json:"total_tests_count,omitempty"`
	TotalCallsCount      uint32   `protobuf:"varint,9,opt,name=total_calls_count,json=totalCallsCount,proto3" json:"total_calls_count,omitempty"`
	TotalChecksCount     uint32   `protobuf:"varint,10,opt,name=total_checks_count,json=totalChecksCount,proto3" json:"total_checks_count,omitempty"`
	TestCallsCount       uint32   `protobuf:"varint,11,opt,name=test_calls_count,json=testCallsCount,proto3" json:"test_calls_count,omitempty"`
	CallChecksCount      uint32   `protobuf:"varint,12,opt,name=call_checks_count,json=callChecksCount,proto3" json:"call_checks_count,omitempty"`
	ShrinkAmount         uint32   `protobuf:"varint,13,opt,name=shrink_amount,json=shrinkAmount,proto3" json:"shrink_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FuzzProgress) Reset()         { *m = FuzzProgress{} }
func (m *FuzzProgress) String() string { return proto.CompactTextString(m) }
func (*FuzzProgress) ProtoMessage()    {}
func (*FuzzProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{3}
}
func (m *FuzzProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FuzzProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FuzzProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FuzzProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuzzProgress.Merge(dst, src)
}
func (m *FuzzProgress) XXX_Size() int {
	return m.Size()
}
func (m *FuzzProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_FuzzProgress.DiscardUnknown(m)
}

var xxx_messageInfo_FuzzProgress proto.InternalMessageInfo

func (m *FuzzProgress) GetFailure() bool {
	if m != nil {
		return m.Failure
	}
	return false
}

func (m *FuzzProgress) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *FuzzProgress) GetLastCallFailure() bool {
	if m != nil {
		return m.LastCallFailure
	}
	return false
}

func (m *FuzzProgress) GetLastCallSuccess() bool {
	if m != nil {
		return m.LastCallSuccess
	}
	return false
}

func (m *FuzzProgress) GetLastCheckFailure() bool {
	if m != nil {
		return m.LastCheckFailure
	}
	return false
}

func (m *FuzzProgress) GetLastCheckSuccess() bool {
	if m != nil {
		return m.LastCheckSuccess
	}
	return false
}

func (m *FuzzProgress) GetShrinking() bool {
	if m != nil {
		return m.Shrinking
	}
	return false
}

func (m *FuzzProgress) GetTotalTestsCount() uint32 {
	if m != nil {
		return m.TotalTestsCount
	}
	return 0
}

func (m *FuzzProgress) GetTotalCallsCount() uint32 {
	if m != nil {
		return m.TotalCallsCount
	}
	return 0
}

func (m *FuzzProgress) GetTotalChecksCount() uint32 {
	if m != nil {
		return m.TotalChecksCount
	}
	return 0
}

func (m *FuzzProgress) GetTestCallsCount() uint32 {
	if m != nil {
		return m.TestCallsCount
	}
	return 0
}

func (m *FuzzProgress) GetCallChecksCount() uint32 {
	if m != nil {
		return m.CallChecksCount
	}
	return 0
}

func (m *FuzzProgress) GetShrinkAmount() uint32 {
	if m != nil {
		return m.ShrinkAmount
	}
	return 0
}

type ReqDoReset struct {
	Kind                 ExecKind `protobuf:"varint,1,opt,name=kind,proto3,enum=lib.ExecKind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqDoReset) Reset()         { *m = ReqDoReset{} }
func (m *ReqDoReset) String() string { return proto.CompactTextString(m) }
func (*ReqDoReset) ProtoMessage()    {}
func (*ReqDoReset) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{4}
}
func (m *ReqDoReset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqDoReset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqDoReset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReqDoReset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqDoReset.Merge(dst, src)
}
func (m *ReqDoReset) XXX_Size() int {
	return m.Size()
}
func (m *ReqDoReset) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqDoReset.DiscardUnknown(m)
}

var xxx_messageInfo_ReqDoReset proto.InternalMessageInfo

func (m *ReqDoReset) GetKind() ExecKind {
	if m != nil {
		return m.Kind
	}
	return ExecKind_UNKNOWN
}

type RepResetProgress struct {
	Failure              bool     `protobuf:"varint,1,opt,name=failure,proto3" json:"failure,omitempty"`
	Success              bool     `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	TsDiff               uint64   `protobuf:"varint,3,opt,name=ts_diff,json=tsDiff,proto3" json:"ts_diff,omitempty"`
	Kind                 ExecKind `protobuf:"varint,4,opt,name=kind,proto3,enum=lib.ExecKind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepResetProgress) Reset()         { *m = RepResetProgress{} }
func (m *RepResetProgress) String() string { return proto.CompactTextString(m) }
func (*RepResetProgress) ProtoMessage()    {}
func (*RepResetProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{5}
}
func (m *RepResetProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepResetProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepResetProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepResetProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepResetProgress.Merge(dst, src)
}
func (m *RepResetProgress) XXX_Size() int {
	return m.Size()
}
func (m *RepResetProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RepResetProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RepResetProgress proto.InternalMessageInfo

func (m *RepResetProgress) GetFailure() bool {
	if m != nil {
		return m.Failure
	}
	return false
}

func (m *RepResetProgress) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *RepResetProgress) GetTsDiff() uint64 {
	if m != nil {
		return m.TsDiff
	}
	return 0
}

func (m *RepResetProgress) GetKind() ExecKind {
	if m != nil {
		return m.Kind
	}
	return ExecKind_UNKNOWN
}

type SUTMetrics struct {
	// A log line
	LogOrigin            string   `protobuf:"bytes,2,opt,name=log_origin,json=logOrigin,proto3" json:"log_origin,omitempty"`
	LogLine              string   `protobuf:"bytes,3,opt,name=log_line,json=logLine,proto3" json:"log_line,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SUTMetrics) Reset()         { *m = SUTMetrics{} }
func (m *SUTMetrics) String() string { return proto.CompactTextString(m) }
func (*SUTMetrics) ProtoMessage()    {}
func (*SUTMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{6}
}
func (m *SUTMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SUTMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SUTMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SUTMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SUTMetrics.Merge(dst, src)
}
func (m *SUTMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SUTMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SUTMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SUTMetrics proto.InternalMessageInfo

func (m *SUTMetrics) GetLogOrigin() string {
	if m != nil {
		return m.LogOrigin
	}
	return ""
}

func (m *SUTMetrics) GetLogLine() string {
	if m != nil {
		return m.LogLine
	}
	return ""
}

type ReqDoCall struct {
	EID                  uint32       `protobuf:"varint,1,opt,name=EID,proto3" json:"EID,omitempty"`
	Request              *HAR_Request `protobuf:"bytes,2,opt,name=request" json:"request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ReqDoCall) Reset()         { *m = ReqDoCall{} }
func (m *ReqDoCall) String() string { return proto.CompactTextString(m) }
func (*ReqDoCall) ProtoMessage()    {}
func (*ReqDoCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{7}
}
func (m *ReqDoCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqDoCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqDoCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReqDoCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqDoCall.Merge(dst, src)
}
func (m *ReqDoCall) XXX_Size() int {
	return m.Size()
}
func (m *ReqDoCall) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqDoCall.DiscardUnknown(m)
}

var xxx_messageInfo_ReqDoCall proto.InternalMessageInfo

func (m *ReqDoCall) GetEID() uint32 {
	if m != nil {
		return m.EID
	}
	return 0
}

func (m *ReqDoCall) GetRequest() *HAR_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

type RepCallDone struct {
	Failure              bool       `protobuf:"varint,1,opt,name=failure,proto3" json:"failure,omitempty"`
	Success              bool       `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	TsDiff               uint64     `protobuf:"varint,3,opt,name=ts_diff,json=tsDiff,proto3" json:"ts_diff,omitempty"`
	Reason               string     `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Response             *HAR_Entry `protobuf:"bytes,5,opt,name=response" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RepCallDone) Reset()         { *m = RepCallDone{} }
func (m *RepCallDone) String() string { return proto.CompactTextString(m) }
func (*RepCallDone) ProtoMessage()    {}
func (*RepCallDone) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{8}
}
func (m *RepCallDone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepCallDone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepCallDone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepCallDone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepCallDone.Merge(dst, src)
}
func (m *RepCallDone) XXX_Size() int {
	return m.Size()
}
func (m *RepCallDone) XXX_DiscardUnknown() {
	xxx_messageInfo_RepCallDone.DiscardUnknown(m)
}

var xxx_messageInfo_RepCallDone proto.InternalMessageInfo

func (m *RepCallDone) GetFailure() bool {
	if m != nil {
		return m.Failure
	}
	return false
}

func (m *RepCallDone) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *RepCallDone) GetTsDiff() uint64 {
	if m != nil {
		return m.TsDiff
	}
	return 0
}

func (m *RepCallDone) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *RepCallDone) GetResponse() *HAR_Entry {
	if m != nil {
		return m.Response
	}
	return nil
}

type RepValidateProgress struct {
	Failure bool `protobuf:"varint,1,opt,name=failure,proto3" json:"failure,omitempty"`
	Success bool `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	// Some info
	Details              []string `protobuf:"bytes,3,rep,name=details" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepValidateProgress) Reset()         { *m = RepValidateProgress{} }
func (m *RepValidateProgress) String() string { return proto.CompactTextString(m) }
func (*RepValidateProgress) ProtoMessage()    {}
func (*RepValidateProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{9}
}
func (m *RepValidateProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepValidateProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepValidateProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepValidateProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepValidateProgress.Merge(dst, src)
}
func (m *RepValidateProgress) XXX_Size() int {
	return m.Size()
}
func (m *RepValidateProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RepValidateProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RepValidateProgress proto.InternalMessageInfo

func (m *RepValidateProgress) GetFailure() bool {
	if m != nil {
		return m.Failure
	}
	return false
}

func (m *RepValidateProgress) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *RepValidateProgress) GetDetails() []string {
	if m != nil {
		return m.Details
	}
	return nil
}

type RepCallResult struct {
	Response             *ValueJSON `protobuf:"bytes,1,opt,name=response" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RepCallResult) Reset()         { *m = RepCallResult{} }
func (m *RepCallResult) String() string { return proto.CompactTextString(m) }
func (*RepCallResult) ProtoMessage()    {}
func (*RepCallResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{10}
}
func (m *RepCallResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepCallResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepCallResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepCallResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepCallResult.Merge(dst, src)
}
func (m *RepCallResult) XXX_Size() int {
	return m.Size()
}
func (m *RepCallResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RepCallResult.DiscardUnknown(m)
}

var xxx_messageInfo_RepCallResult proto.InternalMessageInfo

func (m *RepCallResult) GetResponse() *ValueJSON {
	if m != nil {
		return m.Response
	}
	return nil
}

type UserCfg struct {
	Version              uint32           `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	ApiKey               string           `protobuf:"bytes,2,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	Usage                []string         `protobuf:"bytes,3,rep,name=usage" json:"usage,omitempty"`
	Seed                 []byte           `protobuf:"bytes,4,opt,name=seed,proto3" json:"seed,omitempty"`
	N                    uint32           `protobuf:"varint,5,opt,name=n,proto3" json:"n,omitempty"`
	EIDs                 []uint32         `protobuf:"varint,6,rep,packed,name=EIDs" json:"EIDs,omitempty"`
	Kind                 UserCfg_Kind     `protobuf:"varint,7,opt,name=kind,proto3,enum=lib.UserCfg_Kind" json:"kind,omitempty"`
	File                 string           `protobuf:"bytes,8,opt,name=file,proto3" json:"file,omitempty"`
	Runtime              *UserCfg_Runtime `protobuf:"bytes,9,opt,name=runtime" json:"runtime,omitempty"`
	Exec                 *UserCfg_Exec    `protobuf:"bytes,10,opt,name=exec" json:"exec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UserCfg) Reset()         { *m = UserCfg{} }
func (m *UserCfg) String() string { return proto.CompactTextString(m) }
func (*UserCfg) ProtoMessage()    {}
func (*UserCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{11}
}
func (m *UserCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCfg.Merge(dst, src)
}
func (m *UserCfg) XXX_Size() int {
	return m.Size()
}
func (m *UserCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCfg.DiscardUnknown(m)
}

var xxx_messageInfo_UserCfg proto.InternalMessageInfo

func (m *UserCfg) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *UserCfg) GetApiKey() string {
	if m != nil {
		return m.ApiKey
	}
	return ""
}

func (m *UserCfg) GetUsage() []string {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *UserCfg) GetSeed() []byte {
	if m != nil {
		return m.Seed
	}
	return nil
}

func (m *UserCfg) GetN() uint32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *UserCfg) GetEIDs() []uint32 {
	if m != nil {
		return m.EIDs
	}
	return nil
}

func (m *UserCfg) GetKind() UserCfg_Kind {
	if m != nil {
		return m.Kind
	}
	return UserCfg_UNKNOWN
}

func (m *UserCfg) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

func (m *UserCfg) GetRuntime() *UserCfg_Runtime {
	if m != nil {
		return m.Runtime
	}
	return nil
}

func (m *UserCfg) GetExec() *UserCfg_Exec {
	if m != nil {
		return m.Exec
	}
	return nil
}

type UserCfg_Runtime struct {
	Host                 string   `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Port                 string   `protobuf:"bytes,2,opt,name=port,proto3" json:"port,omitempty"`
	FinalHost            string   `protobuf:"bytes,3,opt,name=final_host,json=finalHost,proto3" json:"final_host,omitempty"`
	FinalPort            string   `protobuf:"bytes,4,opt,name=final_port,json=finalPort,proto3" json:"final_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserCfg_Runtime) Reset()         { *m = UserCfg_Runtime{} }
func (m *UserCfg_Runtime) String() string { return proto.CompactTextString(m) }
func (*UserCfg_Runtime) ProtoMessage()    {}
func (*UserCfg_Runtime) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{11, 0}
}
func (m *UserCfg_Runtime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserCfg_Runtime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserCfg_Runtime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserCfg_Runtime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCfg_Runtime.Merge(dst, src)
}
func (m *UserCfg_Runtime) XXX_Size() int {
	return m.Size()
}
func (m *UserCfg_Runtime) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCfg_Runtime.DiscardUnknown(m)
}

var xxx_messageInfo_UserCfg_Runtime proto.InternalMessageInfo

func (m *UserCfg_Runtime) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *UserCfg_Runtime) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *UserCfg_Runtime) GetFinalHost() string {
	if m != nil {
		return m.FinalHost
	}
	return ""
}

func (m *UserCfg_Runtime) GetFinalPort() string {
	if m != nil {
		return m.FinalPort
	}
	return ""
}

type UserCfg_Exec struct {
	Start                []string `protobuf:"bytes,1,rep,name=start" json:"start,omitempty"`
	Reset_               []string `protobuf:"bytes,2,rep,name=reset" json:"reset,omitempty"`
	Stop                 []string `protobuf:"bytes,3,rep,name=stop" json:"stop,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserCfg_Exec) Reset()         { *m = UserCfg_Exec{} }
func (m *UserCfg_Exec) String() string { return proto.CompactTextString(m) }
func (*UserCfg_Exec) ProtoMessage()    {}
func (*UserCfg_Exec) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{11, 1}
}
func (m *UserCfg_Exec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserCfg_Exec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserCfg_Exec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserCfg_Exec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCfg_Exec.Merge(dst, src)
}
func (m *UserCfg_Exec) XXX_Size() int {
	return m.Size()
}
func (m *UserCfg_Exec) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCfg_Exec.DiscardUnknown(m)
}

var xxx_messageInfo_UserCfg_Exec proto.InternalMessageInfo

func (m *UserCfg_Exec) GetStart() []string {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *UserCfg_Exec) GetReset_() []string {
	if m != nil {
		return m.Reset_
	}
	return nil
}

func (m *UserCfg_Exec) GetStop() []string {
	if m != nil {
		return m.Stop
	}
	return nil
}

type SpecIR struct {
	Schemas *Schemas `protobuf:"bytes,1,opt,name=schemas" json:"schemas,omitempty"`
	// All endpoints are here.
	// Start at 1 then increases monotonously. 0 (zero) is reserved for bug finding.
	Endpoints            map[uint32]*Endpoint `protobuf:"bytes,2,rep,name=endpoints" json:"endpoints,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SpecIR) Reset()         { *m = SpecIR{} }
func (m *SpecIR) String() string { return proto.CompactTextString(m) }
func (*SpecIR) ProtoMessage()    {}
func (*SpecIR) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{12}
}
func (m *SpecIR) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecIR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecIR.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SpecIR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecIR.Merge(dst, src)
}
func (m *SpecIR) XXX_Size() int {
	return m.Size()
}
func (m *SpecIR) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecIR.DiscardUnknown(m)
}

var xxx_messageInfo_SpecIR proto.InternalMessageInfo

func (m *SpecIR) GetSchemas() *Schemas {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *SpecIR) GetEndpoints() map[uint32]*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

type Schemas struct {
	// All schemas are here.
	// Start at 1. 0 (zero) is reserved for bug finding.
	Json                 map[uint32]*RefOrSchemaJSON `protobuf:"bytes,1,rep,name=json" json:"json,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Schemas) Reset()         { *m = Schemas{} }
func (m *Schemas) String() string { return proto.CompactTextString(m) }
func (*Schemas) ProtoMessage()    {}
func (*Schemas) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{13}
}
func (m *Schemas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schemas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schemas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Schemas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schemas.Merge(dst, src)
}
func (m *Schemas) XXX_Size() int {
	return m.Size()
}
func (m *Schemas) XXX_DiscardUnknown() {
	xxx_messageInfo_Schemas.DiscardUnknown(m)
}

var xxx_messageInfo_Schemas proto.InternalMessageInfo

func (m *Schemas) GetJson() map[uint32]*RefOrSchemaJSON {
	if m != nil {
		return m.Json
	}
	return nil
}

type RefOrSchemaJSON struct {
	// Types that are valid to be assigned to PtrOrSchema:
	//	*RefOrSchemaJSON_Ptr
	//	*RefOrSchemaJSON_Schema
	PtrOrSchema          isRefOrSchemaJSON_PtrOrSchema `protobuf_oneof:"ptr_or_schema"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *RefOrSchemaJSON) Reset()         { *m = RefOrSchemaJSON{} }
func (m *RefOrSchemaJSON) String() string { return proto.CompactTextString(m) }
func (*RefOrSchemaJSON) ProtoMessage()    {}
func (*RefOrSchemaJSON) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{14}
}
func (m *RefOrSchemaJSON) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefOrSchemaJSON) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefOrSchemaJSON.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RefOrSchemaJSON) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefOrSchemaJSON.Merge(dst, src)
}
func (m *RefOrSchemaJSON) XXX_Size() int {
	return m.Size()
}
func (m *RefOrSchemaJSON) XXX_DiscardUnknown() {
	xxx_messageInfo_RefOrSchemaJSON.DiscardUnknown(m)
}

var xxx_messageInfo_RefOrSchemaJSON proto.InternalMessageInfo

type isRefOrSchemaJSON_PtrOrSchema interface {
	isRefOrSchemaJSON_PtrOrSchema()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RefOrSchemaJSON_Ptr struct {
	Ptr *SchemaPtr `protobuf:"bytes,1,opt,name=ptr,oneof"`
}
type RefOrSchemaJSON_Schema struct {
	Schema *Schema_JSON `protobuf:"bytes,2,opt,name=schema,oneof"`
}

func (*RefOrSchemaJSON_Ptr) isRefOrSchemaJSON_PtrOrSchema()    {}
func (*RefOrSchemaJSON_Schema) isRefOrSchemaJSON_PtrOrSchema() {}

func (m *RefOrSchemaJSON) GetPtrOrSchema() isRefOrSchemaJSON_PtrOrSchema {
	if m != nil {
		return m.PtrOrSchema
	}
	return nil
}

func (m *RefOrSchemaJSON) GetPtr() *SchemaPtr {
	if x, ok := m.GetPtrOrSchema().(*RefOrSchemaJSON_Ptr); ok {
		return x.Ptr
	}
	return nil
}

func (m *RefOrSchemaJSON) GetSchema() *Schema_JSON {
	if x, ok := m.GetPtrOrSchema().(*RefOrSchemaJSON_Schema); ok {
		return x.Schema
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RefOrSchemaJSON) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RefOrSchemaJSON_OneofMarshaler, _RefOrSchemaJSON_OneofUnmarshaler, _RefOrSchemaJSON_OneofSizer, []interface{}{
		(*RefOrSchemaJSON_Ptr)(nil),
		(*RefOrSchemaJSON_Schema)(nil),
	}
}

func _RefOrSchemaJSON_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RefOrSchemaJSON)
	// ptr_or_schema
	switch x := m.PtrOrSchema.(type) {
	case *RefOrSchemaJSON_Ptr:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ptr); err != nil {
			return err
		}
	case *RefOrSchemaJSON_Schema:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Schema); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RefOrSchemaJSON.PtrOrSchema has unexpected type %T", x)
	}
	return nil
}

func _RefOrSchemaJSON_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RefOrSchemaJSON)
	switch tag {
	case 1: // ptr_or_schema.ptr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaPtr)
		err := b.DecodeMessage(msg)
		m.PtrOrSchema = &RefOrSchemaJSON_Ptr{msg}
		return true, err
	case 2: // ptr_or_schema.schema
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Schema_JSON)
		err := b.DecodeMessage(msg)
		m.PtrOrSchema = &RefOrSchemaJSON_Schema{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RefOrSchemaJSON_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RefOrSchemaJSON)
	// ptr_or_schema
	switch x := m.PtrOrSchema.(type) {
	case *RefOrSchemaJSON_Ptr:
		s := proto.Size(x.Ptr)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RefOrSchemaJSON_Schema:
		s := proto.Size(x.Schema)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SchemaPtr struct {
	// Pointer to actual schema. i.e. key in Schemas message.
	SID uint32 `protobuf:"varint,1,opt,name=SID,proto3" json:"SID,omitempty"`
	// $ref if was ref'd, in canonical/absolute (#/...-like) format.
	Ref                  string   `protobuf:"bytes,2,opt,name=ref,proto3" json:"ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchemaPtr) Reset()         { *m = SchemaPtr{} }
func (m *SchemaPtr) String() string { return proto.CompactTextString(m) }
func (*SchemaPtr) ProtoMessage()    {}
func (*SchemaPtr) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{15}
}
func (m *SchemaPtr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaPtr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaPtr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SchemaPtr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaPtr.Merge(dst, src)
}
func (m *SchemaPtr) XXX_Size() int {
	return m.Size()
}
func (m *SchemaPtr) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaPtr.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaPtr proto.InternalMessageInfo

func (m *SchemaPtr) GetSID() uint32 {
	if m != nil {
		return m.SID
	}
	return 0
}

func (m *SchemaPtr) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

type Endpoint struct {
	// Types that are valid to be assigned to Endpoint:
	//	*Endpoint_Json
	Endpoint             isEndpoint_Endpoint `protobuf_oneof:"endpoint"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{16}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(dst, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

type isEndpoint_Endpoint interface {
	isEndpoint_Endpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Endpoint_Json struct {
	Json *EndpointJSON `protobuf:"bytes,1,opt,name=json,oneof"`
}

func (*Endpoint_Json) isEndpoint_Endpoint() {}

func (m *Endpoint) GetEndpoint() isEndpoint_Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *Endpoint) GetJson() *EndpointJSON {
	if x, ok := m.GetEndpoint().(*Endpoint_Json); ok {
		return x.Json
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Endpoint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Endpoint_OneofMarshaler, _Endpoint_OneofUnmarshaler, _Endpoint_OneofSizer, []interface{}{
		(*Endpoint_Json)(nil),
	}
}

func _Endpoint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Endpoint)
	// endpoint
	switch x := m.Endpoint.(type) {
	case *Endpoint_Json:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Json); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Endpoint.Endpoint has unexpected type %T", x)
	}
	return nil
}

func _Endpoint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Endpoint)
	switch tag {
	case 1: // endpoint.json
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointJSON)
		err := b.DecodeMessage(msg)
		m.Endpoint = &Endpoint_Json{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Endpoint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Endpoint)
	// endpoint
	switch x := m.Endpoint.(type) {
	case *Endpoint_Json:
		s := proto.Size(x.Json)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type EndpointJSON struct {
	Method       EndpointJSON_Method `protobuf:"varint,1,opt,name=method,proto3,enum=lib.EndpointJSON_Method" json:"method,omitempty"`
	PathPartials []*PathPartial      `protobuf:"bytes,2,rep,name=path_partials,json=pathPartials" json:"path_partials,omitempty"`
	Inputs       []*ParamJSON        `protobuf:"bytes,3,rep,name=inputs" json:"inputs,omitempty"`
	// The uint32 key replaces an enum of 1XX,...,201,204,...,5XX,XXX.
	// The uint32 values are SID
	Outputs              map[uint32]uint32 `protobuf:"bytes,4,rep,name=outputs" json:"outputs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EndpointJSON) Reset()         { *m = EndpointJSON{} }
func (m *EndpointJSON) String() string { return proto.CompactTextString(m) }
func (*EndpointJSON) ProtoMessage()    {}
func (*EndpointJSON) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{17}
}
func (m *EndpointJSON) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndpointJSON) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndpointJSON.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EndpointJSON) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndpointJSON.Merge(dst, src)
}
func (m *EndpointJSON) XXX_Size() int {
	return m.Size()
}
func (m *EndpointJSON) XXX_DiscardUnknown() {
	xxx_messageInfo_EndpointJSON.DiscardUnknown(m)
}

var xxx_messageInfo_EndpointJSON proto.InternalMessageInfo

func (m *EndpointJSON) GetMethod() EndpointJSON_Method {
	if m != nil {
		return m.Method
	}
	return EndpointJSON_UNKNOWN
}

func (m *EndpointJSON) GetPathPartials() []*PathPartial {
	if m != nil {
		return m.PathPartials
	}
	return nil
}

func (m *EndpointJSON) GetInputs() []*ParamJSON {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *EndpointJSON) GetOutputs() map[uint32]uint32 {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type ParamJSON struct {
	IsRequired bool   `protobuf:"varint,1,opt,name=is_required,json=isRequired,proto3" json:"is_required,omitempty"`
	SID        uint32 `protobuf:"varint,2,opt,name=SID,proto3" json:"SID,omitempty"`
	// Note: bodies have an empty name
	Name                 string         `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Kind                 ParamJSON_Kind `protobuf:"varint,4,opt,name=kind,proto3,enum=lib.ParamJSON_Kind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ParamJSON) Reset()         { *m = ParamJSON{} }
func (m *ParamJSON) String() string { return proto.CompactTextString(m) }
func (*ParamJSON) ProtoMessage()    {}
func (*ParamJSON) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{18}
}
func (m *ParamJSON) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamJSON) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamJSON.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ParamJSON) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamJSON.Merge(dst, src)
}
func (m *ParamJSON) XXX_Size() int {
	return m.Size()
}
func (m *ParamJSON) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamJSON.DiscardUnknown(m)
}

var xxx_messageInfo_ParamJSON proto.InternalMessageInfo

func (m *ParamJSON) GetIsRequired() bool {
	if m != nil {
		return m.IsRequired
	}
	return false
}

func (m *ParamJSON) GetSID() uint32 {
	if m != nil {
		return m.SID
	}
	return 0
}

func (m *ParamJSON) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ParamJSON) GetKind() ParamJSON_Kind {
	if m != nil {
		return m.Kind
	}
	return ParamJSON_UNKNOWN
}

type PathPartial struct {
	// Types that are valid to be assigned to Pp:
	//	*PathPartial_Part
	//	*PathPartial_Ptr
	Pp                   isPathPartial_Pp `protobuf_oneof:"pp"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PathPartial) Reset()         { *m = PathPartial{} }
func (m *PathPartial) String() string { return proto.CompactTextString(m) }
func (*PathPartial) ProtoMessage()    {}
func (*PathPartial) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{19}
}
func (m *PathPartial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathPartial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathPartial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PathPartial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathPartial.Merge(dst, src)
}
func (m *PathPartial) XXX_Size() int {
	return m.Size()
}
func (m *PathPartial) XXX_DiscardUnknown() {
	xxx_messageInfo_PathPartial.DiscardUnknown(m)
}

var xxx_messageInfo_PathPartial proto.InternalMessageInfo

type isPathPartial_Pp interface {
	isPathPartial_Pp()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PathPartial_Part struct {
	Part string `protobuf:"bytes,1,opt,name=part,proto3,oneof"`
}
type PathPartial_Ptr struct {
	Ptr string `protobuf:"bytes,2,opt,name=ptr,proto3,oneof"`
}

func (*PathPartial_Part) isPathPartial_Pp() {}
func (*PathPartial_Ptr) isPathPartial_Pp()  {}

func (m *PathPartial) GetPp() isPathPartial_Pp {
	if m != nil {
		return m.Pp
	}
	return nil
}

func (m *PathPartial) GetPart() string {
	if x, ok := m.GetPp().(*PathPartial_Part); ok {
		return x.Part
	}
	return ""
}

func (m *PathPartial) GetPtr() string {
	if x, ok := m.GetPp().(*PathPartial_Ptr); ok {
		return x.Ptr
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PathPartial) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PathPartial_OneofMarshaler, _PathPartial_OneofUnmarshaler, _PathPartial_OneofSizer, []interface{}{
		(*PathPartial_Part)(nil),
		(*PathPartial_Ptr)(nil),
	}
}

func _PathPartial_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PathPartial)
	// pp
	switch x := m.Pp.(type) {
	case *PathPartial_Part:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Part)
	case *PathPartial_Ptr:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Ptr)
	case nil:
	default:
		return fmt.Errorf("PathPartial.Pp has unexpected type %T", x)
	}
	return nil
}

func _PathPartial_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PathPartial)
	switch tag {
	case 1: // pp.part
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Pp = &PathPartial_Part{x}
		return true, err
	case 2: // pp.ptr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Pp = &PathPartial_Ptr{x}
		return true, err
	default:
		return false, nil
	}
}

func _PathPartial_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PathPartial)
	// pp
	switch x := m.Pp.(type) {
	case *PathPartial_Part:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Part)))
		n += len(x.Part)
	case *PathPartial_Ptr:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Ptr)))
		n += len(x.Ptr)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Schema struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{20}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(dst, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

type Schema_JSON struct {
	Types        []Schema_JSON_Type `protobuf:"varint,1,rep,packed,name=types,enum=lib.Schema_JSON_Type" json:"types,omitempty"`
	Enum         []*ValueJSON       `protobuf:"bytes,2,rep,name=enum" json:"enum,omitempty"`
	Format       Schema_JSON_Format `protobuf:"varint,3,opt,name=format,proto3,enum=lib.Schema_JSON_Format" json:"format,omitempty"`
	MinLength    uint64             `protobuf:"varint,4,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	MaxLength    uint64             `protobuf:"varint,5,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	HasMaxLength bool               `protobuf:"varint,6,opt,name=has_max_length,json=hasMaxLength,proto3" json:"has_max_length,omitempty"`
	Pattern      string             `protobuf:"bytes,7,opt,name=pattern,proto3" json:"pattern,omitempty"`
	// type: number | integer
	Minimum              float64 `protobuf:"fixed64,8,opt,name=minimum,proto3" json:"minimum,omitempty"`
	Maximum              float64 `protobuf:"fixed64,9,opt,name=maximum,proto3" json:"maximum,omitempty"`
	HasMinimum           bool    `protobuf:"varint,10,opt,name=has_minimum,json=hasMinimum,proto3" json:"has_minimum,omitempty"`
	HasMaximum           bool    `protobuf:"varint,11,opt,name=has_maximum,json=hasMaximum,proto3" json:"has_maximum,omitempty"`
	TranslatedMultipleOf float64 `protobuf:"fixed64,12,opt,name=translated_multiple_of,json=translatedMultipleOf,proto3" json:"translated_multiple_of,omitempty"`
	ExclusiveMinimum     bool    `protobuf:"varint,13,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	ExclusiveMaximum     bool    `protobuf:"varint,14,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	// type: array
	Items       []uint32 `protobuf:"varint,15,rep,packed,name=items" json:"items,omitempty"`
	UniqueItems bool     `protobuf:"varint,16,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	MinItems    uint64   `protobuf:"varint,17,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	MaxItems    uint64   `protobuf:"varint,18,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	HasMaxItems bool     `protobuf:"varint,19,opt,name=has_max_items,json=hasMaxItems,proto3" json:"has_max_items,omitempty"`
	// type: object
	Properties              map[string]uint32                 `protobuf:"bytes,20,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Required                []string                          `protobuf:"bytes,21,rep,name=required" json:"required,omitempty"`
	MinProperties           uint64                            `protobuf:"varint,22,opt,name=min_properties,json=minProperties,proto3" json:"min_properties,omitempty"`
	MaxProperties           uint64                            `protobuf:"varint,23,opt,name=max_properties,json=maxProperties,proto3" json:"max_properties,omitempty"`
	HasMaxProperties        bool                              `protobuf:"varint,24,opt,name=has_max_properties,json=hasMaxProperties,proto3" json:"has_max_properties,omitempty"`
	AdditionalProperties    *Schema_JSON_AdditionalProperties `protobuf:"bytes,25,opt,name=additional_properties,json=additionalProperties" json:"additional_properties,omitempty"`
	HasAdditionalProperties bool                              `protobuf:"varint,26,opt,name=has_additional_properties,json=hasAdditionalProperties,proto3" json:"has_additional_properties,omitempty"`
	AllOf                   []uint32                          `protobuf:"varint,27,rep,packed,name=all_of,json=allOf" json:"all_of,omitempty"`
	AnyOf                   []uint32                          `protobuf:"varint,28,rep,packed,name=any_of,json=anyOf" json:"any_of,omitempty"`
	OneOf                   []uint32                          `protobuf:"varint,29,rep,packed,name=one_of,json=oneOf" json:"one_of,omitempty"`
	Not                     uint32                            `protobuf:"varint,30,opt,name=not,proto3" json:"not,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                          `json:"-"`
	XXX_unrecognized        []byte                            `json:"-"`
	XXX_sizecache           int32                             `json:"-"`
}

func (m *Schema_JSON) Reset()         { *m = Schema_JSON{} }
func (m *Schema_JSON) String() string { return proto.CompactTextString(m) }
func (*Schema_JSON) ProtoMessage()    {}
func (*Schema_JSON) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{20, 0}
}
func (m *Schema_JSON) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema_JSON) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schema_JSON.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Schema_JSON) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema_JSON.Merge(dst, src)
}
func (m *Schema_JSON) XXX_Size() int {
	return m.Size()
}
func (m *Schema_JSON) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema_JSON.DiscardUnknown(m)
}

var xxx_messageInfo_Schema_JSON proto.InternalMessageInfo

func (m *Schema_JSON) GetTypes() []Schema_JSON_Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Schema_JSON) GetEnum() []*ValueJSON {
	if m != nil {
		return m.Enum
	}
	return nil
}

func (m *Schema_JSON) GetFormat() Schema_JSON_Format {
	if m != nil {
		return m.Format
	}
	return Schema_JSON_NONE
}

func (m *Schema_JSON) GetMinLength() uint64 {
	if m != nil {
		return m.MinLength
	}
	return 0
}

func (m *Schema_JSON) GetMaxLength() uint64 {
	if m != nil {
		return m.MaxLength
	}
	return 0
}

func (m *Schema_JSON) GetHasMaxLength() bool {
	if m != nil {
		return m.HasMaxLength
	}
	return false
}

func (m *Schema_JSON) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *Schema_JSON) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *Schema_JSON) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *Schema_JSON) GetHasMinimum() bool {
	if m != nil {
		return m.HasMinimum
	}
	return false
}

func (m *Schema_JSON) GetHasMaximum() bool {
	if m != nil {
		return m.HasMaximum
	}
	return false
}

func (m *Schema_JSON) GetTranslatedMultipleOf() float64 {
	if m != nil {
		return m.TranslatedMultipleOf
	}
	return 0
}

func (m *Schema_JSON) GetExclusiveMinimum() bool {
	if m != nil {
		return m.ExclusiveMinimum
	}
	return false
}

func (m *Schema_JSON) GetExclusiveMaximum() bool {
	if m != nil {
		return m.ExclusiveMaximum
	}
	return false
}

func (m *Schema_JSON) GetItems() []uint32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Schema_JSON) GetUniqueItems() bool {
	if m != nil {
		return m.UniqueItems
	}
	return false
}

func (m *Schema_JSON) GetMinItems() uint64 {
	if m != nil {
		return m.MinItems
	}
	return 0
}

func (m *Schema_JSON) GetMaxItems() uint64 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *Schema_JSON) GetHasMaxItems() bool {
	if m != nil {
		return m.HasMaxItems
	}
	return false
}

func (m *Schema_JSON) GetProperties() map[string]uint32 {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Schema_JSON) GetRequired() []string {
	if m != nil {
		return m.Required
	}
	return nil
}

func (m *Schema_JSON) GetMinProperties() uint64 {
	if m != nil {
		return m.MinProperties
	}
	return 0
}

func (m *Schema_JSON) GetMaxProperties() uint64 {
	if m != nil {
		return m.MaxProperties
	}
	return 0
}

func (m *Schema_JSON) GetHasMaxProperties() bool {
	if m != nil {
		return m.HasMaxProperties
	}
	return false
}

func (m *Schema_JSON) GetAdditionalProperties() *Schema_JSON_AdditionalProperties {
	if m != nil {
		return m.AdditionalProperties
	}
	return nil
}

func (m *Schema_JSON) GetHasAdditionalProperties() bool {
	if m != nil {
		return m.HasAdditionalProperties
	}
	return false
}

func (m *Schema_JSON) GetAllOf() []uint32 {
	if m != nil {
		return m.AllOf
	}
	return nil
}

func (m *Schema_JSON) GetAnyOf() []uint32 {
	if m != nil {
		return m.AnyOf
	}
	return nil
}

func (m *Schema_JSON) GetOneOf() []uint32 {
	if m != nil {
		return m.OneOf
	}
	return nil
}

func (m *Schema_JSON) GetNot() uint32 {
	if m != nil {
		return m.Not
	}
	return 0
}

// / FIXME true is equivalent to {}, false is equivalent to {"not": {}}
type Schema_JSON_AdditionalProperties struct {
	// Types that are valid to be assigned to AddProps:
	//	*Schema_JSON_AdditionalProperties_AlwaysSucceed
	//	*Schema_JSON_AdditionalProperties_SID
	AddProps             isSchema_JSON_AdditionalProperties_AddProps `protobuf_oneof:"add_props"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *Schema_JSON_AdditionalProperties) Reset()         { *m = Schema_JSON_AdditionalProperties{} }
func (m *Schema_JSON_AdditionalProperties) String() string { return proto.CompactTextString(m) }
func (*Schema_JSON_AdditionalProperties) ProtoMessage()    {}
func (*Schema_JSON_AdditionalProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{20, 0, 1}
}
func (m *Schema_JSON_AdditionalProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema_JSON_AdditionalProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schema_JSON_AdditionalProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Schema_JSON_AdditionalProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema_JSON_AdditionalProperties.Merge(dst, src)
}
func (m *Schema_JSON_AdditionalProperties) XXX_Size() int {
	return m.Size()
}
func (m *Schema_JSON_AdditionalProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema_JSON_AdditionalProperties.DiscardUnknown(m)
}

var xxx_messageInfo_Schema_JSON_AdditionalProperties proto.InternalMessageInfo

type isSchema_JSON_AdditionalProperties_AddProps interface {
	isSchema_JSON_AdditionalProperties_AddProps()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Schema_JSON_AdditionalProperties_AlwaysSucceed struct {
	AlwaysSucceed bool `protobuf:"varint,1,opt,name=always_succeed,json=alwaysSucceed,proto3,oneof"`
}
type Schema_JSON_AdditionalProperties_SID struct {
	SID uint32 `protobuf:"varint,2,opt,name=SID,proto3,oneof"`
}

func (*Schema_JSON_AdditionalProperties_AlwaysSucceed) isSchema_JSON_AdditionalProperties_AddProps() {}
func (*Schema_JSON_AdditionalProperties_SID) isSchema_JSON_AdditionalProperties_AddProps()           {}

func (m *Schema_JSON_AdditionalProperties) GetAddProps() isSchema_JSON_AdditionalProperties_AddProps {
	if m != nil {
		return m.AddProps
	}
	return nil
}

func (m *Schema_JSON_AdditionalProperties) GetAlwaysSucceed() bool {
	if x, ok := m.GetAddProps().(*Schema_JSON_AdditionalProperties_AlwaysSucceed); ok {
		return x.AlwaysSucceed
	}
	return false
}

func (m *Schema_JSON_AdditionalProperties) GetSID() uint32 {
	if x, ok := m.GetAddProps().(*Schema_JSON_AdditionalProperties_SID); ok {
		return x.SID
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Schema_JSON_AdditionalProperties) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Schema_JSON_AdditionalProperties_OneofMarshaler, _Schema_JSON_AdditionalProperties_OneofUnmarshaler, _Schema_JSON_AdditionalProperties_OneofSizer, []interface{}{
		(*Schema_JSON_AdditionalProperties_AlwaysSucceed)(nil),
		(*Schema_JSON_AdditionalProperties_SID)(nil),
	}
}

func _Schema_JSON_AdditionalProperties_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Schema_JSON_AdditionalProperties)
	// add_props
	switch x := m.AddProps.(type) {
	case *Schema_JSON_AdditionalProperties_AlwaysSucceed:
		t := uint64(0)
		if x.AlwaysSucceed {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Schema_JSON_AdditionalProperties_SID:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.SID))
	case nil:
	default:
		return fmt.Errorf("Schema_JSON_AdditionalProperties.AddProps has unexpected type %T", x)
	}
	return nil
}

func _Schema_JSON_AdditionalProperties_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Schema_JSON_AdditionalProperties)
	switch tag {
	case 1: // add_props.always_succeed
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.AddProps = &Schema_JSON_AdditionalProperties_AlwaysSucceed{x != 0}
		return true, err
	case 2: // add_props.SID
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.AddProps = &Schema_JSON_AdditionalProperties_SID{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Schema_JSON_AdditionalProperties_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Schema_JSON_AdditionalProperties)
	// add_props
	switch x := m.AddProps.(type) {
	case *Schema_JSON_AdditionalProperties_AlwaysSucceed:
		n += 1 // tag and wire
		n += 1
	case *Schema_JSON_AdditionalProperties_SID:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.SID))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ArrayJSON struct {
	Values               []*ValueJSON `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ArrayJSON) Reset()         { *m = ArrayJSON{} }
func (m *ArrayJSON) String() string { return proto.CompactTextString(m) }
func (*ArrayJSON) ProtoMessage()    {}
func (*ArrayJSON) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{21}
}
func (m *ArrayJSON) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArrayJSON) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArrayJSON.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ArrayJSON) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArrayJSON.Merge(dst, src)
}
func (m *ArrayJSON) XXX_Size() int {
	return m.Size()
}
func (m *ArrayJSON) XXX_DiscardUnknown() {
	xxx_messageInfo_ArrayJSON.DiscardUnknown(m)
}

var xxx_messageInfo_ArrayJSON proto.InternalMessageInfo

func (m *ArrayJSON) GetValues() []*ValueJSON {
	if m != nil {
		return m.Values
	}
	return nil
}

type ObjectJSON struct {
	Values               map[string]*ValueJSON `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ObjectJSON) Reset()         { *m = ObjectJSON{} }
func (m *ObjectJSON) String() string { return proto.CompactTextString(m) }
func (*ObjectJSON) ProtoMessage()    {}
func (*ObjectJSON) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{22}
}
func (m *ObjectJSON) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectJSON) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectJSON.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ObjectJSON) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectJSON.Merge(dst, src)
}
func (m *ObjectJSON) XXX_Size() int {
	return m.Size()
}
func (m *ObjectJSON) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectJSON.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectJSON proto.InternalMessageInfo

func (m *ObjectJSON) GetValues() map[string]*ValueJSON {
	if m != nil {
		return m.Values
	}
	return nil
}

// TODO: replace with https://github.com/protocolbuffers/protobuf/blob/f2a919f58f12574ac04ca79e6b84577dec6f2b43/src/google/protobuf/struct.proto#L62
type ValueJSON struct {
	// Types that are valid to be assigned to Value:
	//	*ValueJSON_IsNull
	//	*ValueJSON_Boolean
	//	*ValueJSON_Number
	//	*ValueJSON_Text
	//	*ValueJSON_Array
	//	*ValueJSON_Object
	Value                isValueJSON_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ValueJSON) Reset()         { *m = ValueJSON{} }
func (m *ValueJSON) String() string { return proto.CompactTextString(m) }
func (*ValueJSON) ProtoMessage()    {}
func (*ValueJSON) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{23}
}
func (m *ValueJSON) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueJSON) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueJSON.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ValueJSON) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueJSON.Merge(dst, src)
}
func (m *ValueJSON) XXX_Size() int {
	return m.Size()
}
func (m *ValueJSON) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueJSON.DiscardUnknown(m)
}

var xxx_messageInfo_ValueJSON proto.InternalMessageInfo

type isValueJSON_Value interface {
	isValueJSON_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ValueJSON_IsNull struct {
	IsNull bool `protobuf:"varint,1,opt,name=is_null,json=isNull,proto3,oneof"`
}
type ValueJSON_Boolean struct {
	Boolean bool `protobuf:"varint,2,opt,name=boolean,proto3,oneof"`
}
type ValueJSON_Number struct {
	Number float64 `protobuf:"fixed64,3,opt,name=number,proto3,oneof"`
}
type ValueJSON_Text struct {
	Text string `protobuf:"bytes,4,opt,name=text,proto3,oneof"`
}
type ValueJSON_Array struct {
	Array *ArrayJSON `protobuf:"bytes,5,opt,name=array,oneof"`
}
type ValueJSON_Object struct {
	Object *ObjectJSON `protobuf:"bytes,6,opt,name=object,oneof"`
}

func (*ValueJSON_IsNull) isValueJSON_Value()  {}
func (*ValueJSON_Boolean) isValueJSON_Value() {}
func (*ValueJSON_Number) isValueJSON_Value()  {}
func (*ValueJSON_Text) isValueJSON_Value()    {}
func (*ValueJSON_Array) isValueJSON_Value()   {}
func (*ValueJSON_Object) isValueJSON_Value()  {}

func (m *ValueJSON) GetValue() isValueJSON_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ValueJSON) GetIsNull() bool {
	if x, ok := m.GetValue().(*ValueJSON_IsNull); ok {
		return x.IsNull
	}
	return false
}

func (m *ValueJSON) GetBoolean() bool {
	if x, ok := m.GetValue().(*ValueJSON_Boolean); ok {
		return x.Boolean
	}
	return false
}

func (m *ValueJSON) GetNumber() float64 {
	if x, ok := m.GetValue().(*ValueJSON_Number); ok {
		return x.Number
	}
	return 0
}

func (m *ValueJSON) GetText() string {
	if x, ok := m.GetValue().(*ValueJSON_Text); ok {
		return x.Text
	}
	return ""
}

func (m *ValueJSON) GetArray() *ArrayJSON {
	if x, ok := m.GetValue().(*ValueJSON_Array); ok {
		return x.Array
	}
	return nil
}

func (m *ValueJSON) GetObject() *ObjectJSON {
	if x, ok := m.GetValue().(*ValueJSON_Object); ok {
		return x.Object
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ValueJSON) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ValueJSON_OneofMarshaler, _ValueJSON_OneofUnmarshaler, _ValueJSON_OneofSizer, []interface{}{
		(*ValueJSON_IsNull)(nil),
		(*ValueJSON_Boolean)(nil),
		(*ValueJSON_Number)(nil),
		(*ValueJSON_Text)(nil),
		(*ValueJSON_Array)(nil),
		(*ValueJSON_Object)(nil),
	}
}

func _ValueJSON_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ValueJSON)
	// value
	switch x := m.Value.(type) {
	case *ValueJSON_IsNull:
		t := uint64(0)
		if x.IsNull {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ValueJSON_Boolean:
		t := uint64(0)
		if x.Boolean {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ValueJSON_Number:
		_ = b.EncodeVarint(3<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.Number))
	case *ValueJSON_Text:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Text)
	case *ValueJSON_Array:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Array); err != nil {
			return err
		}
	case *ValueJSON_Object:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Object); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ValueJSON.Value has unexpected type %T", x)
	}
	return nil
}

func _ValueJSON_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ValueJSON)
	switch tag {
	case 1: // value.is_null
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &ValueJSON_IsNull{x != 0}
		return true, err
	case 2: // value.boolean
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &ValueJSON_Boolean{x != 0}
		return true, err
	case 3: // value.number
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &ValueJSON_Number{math.Float64frombits(x)}
		return true, err
	case 4: // value.text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &ValueJSON_Text{x}
		return true, err
	case 5: // value.array
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ArrayJSON)
		err := b.DecodeMessage(msg)
		m.Value = &ValueJSON_Array{msg}
		return true, err
	case 6: // value.object
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObjectJSON)
		err := b.DecodeMessage(msg)
		m.Value = &ValueJSON_Object{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ValueJSON_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ValueJSON)
	// value
	switch x := m.Value.(type) {
	case *ValueJSON_IsNull:
		n += 1 // tag and wire
		n += 1
	case *ValueJSON_Boolean:
		n += 1 // tag and wire
		n += 1
	case *ValueJSON_Number:
		n += 1 // tag and wire
		n += 8
	case *ValueJSON_Text:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Text)))
		n += len(x.Text)
	case *ValueJSON_Array:
		s := proto.Size(x.Array)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ValueJSON_Object:
		s := proto.Size(x.Object)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TODO: split this into dedicated package
// http://www.softwareishard.com/blog/har-12-spec/
// NOTE: durations are in nanoseconds instead of milliseconds
type HAR struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR) Reset()         { *m = HAR{} }
func (m *HAR) String() string { return proto.CompactTextString(m) }
func (*HAR) ProtoMessage()    {}
func (*HAR) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24}
}
func (m *HAR) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR.Merge(dst, src)
}
func (m *HAR) XXX_Size() int {
	return m.Size()
}
func (m *HAR) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR.DiscardUnknown(m)
}

var xxx_messageInfo_HAR proto.InternalMessageInfo

type HAR_Request struct {
	Comment              string        `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	BodySize             int32         `protobuf:"varint,2,opt,name=body_size,json=bodySize,proto3" json:"body_size,omitempty"`
	HeadersSize          int32         `protobuf:"varint,3,opt,name=headers_size,json=headersSize,proto3" json:"headers_size,omitempty"`
	Headers              []*HAR_Header `protobuf:"bytes,4,rep,name=headers" json:"headers,omitempty"`
	Cookies              []*HAR_Cookie `protobuf:"bytes,5,rep,name=cookies" json:"cookies,omitempty"`
	HttpVersion          string        `protobuf:"bytes,6,opt,name=http_version,json=httpVersion,proto3" json:"http_version,omitempty"`
	Method               string        `protobuf:"bytes,7,opt,name=method,proto3" json:"method,omitempty"`
	URL                  string        `protobuf:"bytes,8,opt,name=URL,proto3" json:"URL,omitempty"`
	PostData             *HAR_PostData `protobuf:"bytes,9,opt,name=post_data,json=postData" json:"post_data,omitempty"`
	QueryString          []*HAR_Query  `protobuf:"bytes,10,rep,name=query_string,json=queryString" json:"query_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *HAR_Request) Reset()         { *m = HAR_Request{} }
func (m *HAR_Request) String() string { return proto.CompactTextString(m) }
func (*HAR_Request) ProtoMessage()    {}
func (*HAR_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 0}
}
func (m *HAR_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Request.Merge(dst, src)
}
func (m *HAR_Request) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Request.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Request proto.InternalMessageInfo

func (m *HAR_Request) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Request) GetBodySize() int32 {
	if m != nil {
		return m.BodySize
	}
	return 0
}

func (m *HAR_Request) GetHeadersSize() int32 {
	if m != nil {
		return m.HeadersSize
	}
	return 0
}

func (m *HAR_Request) GetHeaders() []*HAR_Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HAR_Request) GetCookies() []*HAR_Cookie {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *HAR_Request) GetHttpVersion() string {
	if m != nil {
		return m.HttpVersion
	}
	return ""
}

func (m *HAR_Request) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *HAR_Request) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *HAR_Request) GetPostData() *HAR_PostData {
	if m != nil {
		return m.PostData
	}
	return nil
}

func (m *HAR_Request) GetQueryString() []*HAR_Query {
	if m != nil {
		return m.QueryString
	}
	return nil
}

type HAR_Response struct {
	Comment              string        `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	BodySize             int32         `protobuf:"varint,2,opt,name=body_size,json=bodySize,proto3" json:"body_size,omitempty"`
	HeadersSize          int32         `protobuf:"varint,3,opt,name=headers_size,json=headersSize,proto3" json:"headers_size,omitempty"`
	Headers              []*HAR_Header `protobuf:"bytes,4,rep,name=headers" json:"headers,omitempty"`
	Cookies              []*HAR_Cookie `protobuf:"bytes,5,rep,name=cookies" json:"cookies,omitempty"`
	HttpVersion          string        `protobuf:"bytes,6,opt,name=http_version,json=httpVersion,proto3" json:"http_version,omitempty"`
	Content              *HAR_Content  `protobuf:"bytes,7,opt,name=content" json:"content,omitempty"`
	Redirect_URL         string        `protobuf:"bytes,8,opt,name=redirect_URL,json=redirectURL,proto3" json:"redirect_URL,omitempty"`
	Status               uint32        `protobuf:"varint,9,opt,name=status,proto3" json:"status,omitempty"`
	StatusText           string        `protobuf:"bytes,10,opt,name=status_text,json=statusText,proto3" json:"status_text,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *HAR_Response) Reset()         { *m = HAR_Response{} }
func (m *HAR_Response) String() string { return proto.CompactTextString(m) }
func (*HAR_Response) ProtoMessage()    {}
func (*HAR_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 1}
}
func (m *HAR_Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Response.Merge(dst, src)
}
func (m *HAR_Response) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Response.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Response proto.InternalMessageInfo

func (m *HAR_Response) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Response) GetBodySize() int32 {
	if m != nil {
		return m.BodySize
	}
	return 0
}

func (m *HAR_Response) GetHeadersSize() int32 {
	if m != nil {
		return m.HeadersSize
	}
	return 0
}

func (m *HAR_Response) GetHeaders() []*HAR_Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HAR_Response) GetCookies() []*HAR_Cookie {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *HAR_Response) GetHttpVersion() string {
	if m != nil {
		return m.HttpVersion
	}
	return ""
}

func (m *HAR_Response) GetContent() *HAR_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *HAR_Response) GetRedirect_URL() string {
	if m != nil {
		return m.Redirect_URL
	}
	return ""
}

func (m *HAR_Response) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *HAR_Response) GetStatusText() string {
	if m != nil {
		return m.StatusText
	}
	return ""
}

type HAR_AroundRequest struct {
	Comment string `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	ETag    string `protobuf:"bytes,2,opt,name=e_tag,json=eTag,proto3" json:"e_tag,omitempty"`
	// iso8601
	Expires  string `protobuf:"bytes,3,opt,name=expires,proto3" json:"expires,omitempty"`
	HitCount uint32 `protobuf:"varint,4,opt,name=hit_count,json=hitCount,proto3" json:"hit_count,omitempty"`
	// iso8601
	LastAccess           string   `protobuf:"bytes,5,opt,name=last_access,json=lastAccess,proto3" json:"last_access,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_AroundRequest) Reset()         { *m = HAR_AroundRequest{} }
func (m *HAR_AroundRequest) String() string { return proto.CompactTextString(m) }
func (*HAR_AroundRequest) ProtoMessage()    {}
func (*HAR_AroundRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 2}
}
func (m *HAR_AroundRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_AroundRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_AroundRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_AroundRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_AroundRequest.Merge(dst, src)
}
func (m *HAR_AroundRequest) XXX_Size() int {
	return m.Size()
}
func (m *HAR_AroundRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_AroundRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_AroundRequest proto.InternalMessageInfo

func (m *HAR_AroundRequest) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_AroundRequest) GetETag() string {
	if m != nil {
		return m.ETag
	}
	return ""
}

func (m *HAR_AroundRequest) GetExpires() string {
	if m != nil {
		return m.Expires
	}
	return ""
}

func (m *HAR_AroundRequest) GetHitCount() uint32 {
	if m != nil {
		return m.HitCount
	}
	return 0
}

func (m *HAR_AroundRequest) GetLastAccess() string {
	if m != nil {
		return m.LastAccess
	}
	return ""
}

type HAR_Browser struct {
	Comment              string   `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Version              string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_Browser) Reset()         { *m = HAR_Browser{} }
func (m *HAR_Browser) String() string { return proto.CompactTextString(m) }
func (*HAR_Browser) ProtoMessage()    {}
func (*HAR_Browser) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 3}
}
func (m *HAR_Browser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Browser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Browser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Browser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Browser.Merge(dst, src)
}
func (m *HAR_Browser) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Browser) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Browser.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Browser proto.InternalMessageInfo

func (m *HAR_Browser) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Browser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HAR_Browser) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type HAR_Cache struct {
	Comment              string             `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	AfterRequest         *HAR_AroundRequest `protobuf:"bytes,2,opt,name=after_request,json=afterRequest" json:"after_request,omitempty"`
	BeforeRequest        *HAR_AroundRequest `protobuf:"bytes,3,opt,name=before_request,json=beforeRequest" json:"before_request,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *HAR_Cache) Reset()         { *m = HAR_Cache{} }
func (m *HAR_Cache) String() string { return proto.CompactTextString(m) }
func (*HAR_Cache) ProtoMessage()    {}
func (*HAR_Cache) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 4}
}
func (m *HAR_Cache) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Cache) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Cache.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Cache) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Cache.Merge(dst, src)
}
func (m *HAR_Cache) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Cache) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Cache.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Cache proto.InternalMessageInfo

func (m *HAR_Cache) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Cache) GetAfterRequest() *HAR_AroundRequest {
	if m != nil {
		return m.AfterRequest
	}
	return nil
}

func (m *HAR_Cache) GetBeforeRequest() *HAR_AroundRequest {
	if m != nil {
		return m.BeforeRequest
	}
	return nil
}

type HAR_Content struct {
	Comment     string `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Compression int32  `protobuf:"varint,2,opt,name=compression,proto3" json:"compression,omitempty"`
	Encoding    string `protobuf:"bytes,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
	MimeType    string `protobuf:"bytes,4,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	// Renamed `size` to `length` to avoid conflict with gogofast
	Length               int32    `protobuf:"varint,5,opt,name=length,proto3" json:"length,omitempty"`
	Text                 string   `protobuf:"bytes,6,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_Content) Reset()         { *m = HAR_Content{} }
func (m *HAR_Content) String() string { return proto.CompactTextString(m) }
func (*HAR_Content) ProtoMessage()    {}
func (*HAR_Content) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 5}
}
func (m *HAR_Content) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Content) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Content.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Content) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Content.Merge(dst, src)
}
func (m *HAR_Content) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Content) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Content.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Content proto.InternalMessageInfo

func (m *HAR_Content) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Content) GetCompression() int32 {
	if m != nil {
		return m.Compression
	}
	return 0
}

func (m *HAR_Content) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *HAR_Content) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *HAR_Content) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *HAR_Content) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type HAR_Cookie struct {
	Comment string `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Domain  string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// iso8601
	Expires              string   `protobuf:"bytes,3,opt,name=expires,proto3" json:"expires,omitempty"`
	HttpOnly             bool     `protobuf:"varint,4,opt,name=http_only,json=httpOnly,proto3" json:"http_only,omitempty"`
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Path                 string   `protobuf:"bytes,6,opt,name=path,proto3" json:"path,omitempty"`
	Secure               bool     `protobuf:"varint,7,opt,name=secure,proto3" json:"secure,omitempty"`
	Value                string   `protobuf:"bytes,8,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_Cookie) Reset()         { *m = HAR_Cookie{} }
func (m *HAR_Cookie) String() string { return proto.CompactTextString(m) }
func (*HAR_Cookie) ProtoMessage()    {}
func (*HAR_Cookie) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 6}
}
func (m *HAR_Cookie) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Cookie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Cookie.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Cookie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Cookie.Merge(dst, src)
}
func (m *HAR_Cookie) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Cookie) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Cookie.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Cookie proto.InternalMessageInfo

func (m *HAR_Cookie) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Cookie) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *HAR_Cookie) GetExpires() string {
	if m != nil {
		return m.Expires
	}
	return ""
}

func (m *HAR_Cookie) GetHttpOnly() bool {
	if m != nil {
		return m.HttpOnly
	}
	return false
}

func (m *HAR_Cookie) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HAR_Cookie) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HAR_Cookie) GetSecure() bool {
	if m != nil {
		return m.Secure
	}
	return false
}

func (m *HAR_Cookie) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type HAR_Creator struct {
	Comment              string   `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Version              string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_Creator) Reset()         { *m = HAR_Creator{} }
func (m *HAR_Creator) String() string { return proto.CompactTextString(m) }
func (*HAR_Creator) ProtoMessage()    {}
func (*HAR_Creator) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 7}
}
func (m *HAR_Creator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Creator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Creator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Creator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Creator.Merge(dst, src)
}
func (m *HAR_Creator) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Creator) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Creator.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Creator proto.InternalMessageInfo

func (m *HAR_Creator) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Creator) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HAR_Creator) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type HAR_Entry struct {
	Comment          string        `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Cache            *HAR_Cache    `protobuf:"bytes,2,opt,name=cache" json:"cache,omitempty"`
	Connection       string        `protobuf:"bytes,3,opt,name=connection,proto3" json:"connection,omitempty"`
	PageRef          string        `protobuf:"bytes,4,opt,name=page_ref,json=pageRef,proto3" json:"page_ref,omitempty"`
	Request          *HAR_Request  `protobuf:"bytes,5,opt,name=request" json:"request,omitempty"`
	Response         *HAR_Response `protobuf:"bytes,6,opt,name=response" json:"response,omitempty"`
	Server_IPAddress string        `protobuf:"bytes,7,opt,name=server_IP_address,json=serverIPAddress,proto3" json:"server_IP_address,omitempty"`
	// iso8601
	StartedDateTime      string       `protobuf:"bytes,8,opt,name=started_date_time,json=startedDateTime,proto3" json:"started_date_time,omitempty"`
	Time                 int64        `protobuf:"varint,9,opt,name=time,proto3" json:"time,omitempty"`
	Timings              *HAR_Timings `protobuf:"bytes,10,opt,name=timings" json:"timings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HAR_Entry) Reset()         { *m = HAR_Entry{} }
func (m *HAR_Entry) String() string { return proto.CompactTextString(m) }
func (*HAR_Entry) ProtoMessage()    {}
func (*HAR_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 8}
}
func (m *HAR_Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Entry.Merge(dst, src)
}
func (m *HAR_Entry) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Entry proto.InternalMessageInfo

func (m *HAR_Entry) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Entry) GetCache() *HAR_Cache {
	if m != nil {
		return m.Cache
	}
	return nil
}

func (m *HAR_Entry) GetConnection() string {
	if m != nil {
		return m.Connection
	}
	return ""
}

func (m *HAR_Entry) GetPageRef() string {
	if m != nil {
		return m.PageRef
	}
	return ""
}

func (m *HAR_Entry) GetRequest() *HAR_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *HAR_Entry) GetResponse() *HAR_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *HAR_Entry) GetServer_IPAddress() string {
	if m != nil {
		return m.Server_IPAddress
	}
	return ""
}

func (m *HAR_Entry) GetStartedDateTime() string {
	if m != nil {
		return m.StartedDateTime
	}
	return ""
}

func (m *HAR_Entry) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *HAR_Entry) GetTimings() *HAR_Timings {
	if m != nil {
		return m.Timings
	}
	return nil
}

type HAR_Header struct {
	Comment              string   `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Value                string   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_Header) Reset()         { *m = HAR_Header{} }
func (m *HAR_Header) String() string { return proto.CompactTextString(m) }
func (*HAR_Header) ProtoMessage()    {}
func (*HAR_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 9}
}
func (m *HAR_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Header.Merge(dst, src)
}
func (m *HAR_Header) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Header.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Header proto.InternalMessageInfo

func (m *HAR_Header) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Header) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HAR_Header) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type HAR_Log struct {
	Comment              string       `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Browser              *HAR_Browser `protobuf:"bytes,2,opt,name=browser" json:"browser,omitempty"`
	Creator              *HAR_Creator `protobuf:"bytes,3,opt,name=creator" json:"creator,omitempty"`
	Entries              []*HAR_Entry `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
	Pages                []*HAR_Page  `protobuf:"bytes,5,rep,name=pages" json:"pages,omitempty"`
	Version              string       `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HAR_Log) Reset()         { *m = HAR_Log{} }
func (m *HAR_Log) String() string { return proto.CompactTextString(m) }
func (*HAR_Log) ProtoMessage()    {}
func (*HAR_Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 10}
}
func (m *HAR_Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Log.Merge(dst, src)
}
func (m *HAR_Log) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Log) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Log.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Log proto.InternalMessageInfo

func (m *HAR_Log) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Log) GetBrowser() *HAR_Browser {
	if m != nil {
		return m.Browser
	}
	return nil
}

func (m *HAR_Log) GetCreator() *HAR_Creator {
	if m != nil {
		return m.Creator
	}
	return nil
}

func (m *HAR_Log) GetEntries() []*HAR_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *HAR_Log) GetPages() []*HAR_Page {
	if m != nil {
		return m.Pages
	}
	return nil
}

func (m *HAR_Log) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type HAR_Page struct {
	Comment     string           `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Id          string           `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	PageTimings *HAR_PageTimings `protobuf:"bytes,3,opt,name=page_timings,json=pageTimings" json:"page_timings,omitempty"`
	// iso8601
	StartedDateTime      string   `protobuf:"bytes,4,opt,name=started_date_time,json=startedDateTime,proto3" json:"started_date_time,omitempty"`
	Title                string   `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_Page) Reset()         { *m = HAR_Page{} }
func (m *HAR_Page) String() string { return proto.CompactTextString(m) }
func (*HAR_Page) ProtoMessage()    {}
func (*HAR_Page) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 11}
}
func (m *HAR_Page) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Page) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Page.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Page) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Page.Merge(dst, src)
}
func (m *HAR_Page) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Page) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Page.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Page proto.InternalMessageInfo

func (m *HAR_Page) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Page) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *HAR_Page) GetPageTimings() *HAR_PageTimings {
	if m != nil {
		return m.PageTimings
	}
	return nil
}

func (m *HAR_Page) GetStartedDateTime() string {
	if m != nil {
		return m.StartedDateTime
	}
	return ""
}

func (m *HAR_Page) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

type HAR_PageTimings struct {
	Comment              string   `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	OnContentLoad        int64    `protobuf:"varint,2,opt,name=on_content_load,json=onContentLoad,proto3" json:"on_content_load,omitempty"`
	OnLoad               int64    `protobuf:"varint,3,opt,name=on_load,json=onLoad,proto3" json:"on_load,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_PageTimings) Reset()         { *m = HAR_PageTimings{} }
func (m *HAR_PageTimings) String() string { return proto.CompactTextString(m) }
func (*HAR_PageTimings) ProtoMessage()    {}
func (*HAR_PageTimings) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 12}
}
func (m *HAR_PageTimings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_PageTimings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_PageTimings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_PageTimings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_PageTimings.Merge(dst, src)
}
func (m *HAR_PageTimings) XXX_Size() int {
	return m.Size()
}
func (m *HAR_PageTimings) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_PageTimings.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_PageTimings proto.InternalMessageInfo

func (m *HAR_PageTimings) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_PageTimings) GetOnContentLoad() int64 {
	if m != nil {
		return m.OnContentLoad
	}
	return 0
}

func (m *HAR_PageTimings) GetOnLoad() int64 {
	if m != nil {
		return m.OnLoad
	}
	return 0
}

type HAR_PostData struct {
	Comment              string               `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	MimeType             string               `protobuf:"bytes,2,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	Params               []*HAR_PostDataParam `protobuf:"bytes,3,rep,name=params" json:"params,omitempty"`
	Text                 string               `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *HAR_PostData) Reset()         { *m = HAR_PostData{} }
func (m *HAR_PostData) String() string { return proto.CompactTextString(m) }
func (*HAR_PostData) ProtoMessage()    {}
func (*HAR_PostData) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 13}
}
func (m *HAR_PostData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_PostData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_PostData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_PostData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_PostData.Merge(dst, src)
}
func (m *HAR_PostData) XXX_Size() int {
	return m.Size()
}
func (m *HAR_PostData) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_PostData.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_PostData proto.InternalMessageInfo

func (m *HAR_PostData) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_PostData) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *HAR_PostData) GetParams() []*HAR_PostDataParam {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *HAR_PostData) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type HAR_PostDataParam struct {
	Comment              string   `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	ContentType          string   `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	FileName             string   `protobuf:"bytes,3,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Value                string   `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_PostDataParam) Reset()         { *m = HAR_PostDataParam{} }
func (m *HAR_PostDataParam) String() string { return proto.CompactTextString(m) }
func (*HAR_PostDataParam) ProtoMessage()    {}
func (*HAR_PostDataParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 14}
}
func (m *HAR_PostDataParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_PostDataParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_PostDataParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_PostDataParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_PostDataParam.Merge(dst, src)
}
func (m *HAR_PostDataParam) XXX_Size() int {
	return m.Size()
}
func (m *HAR_PostDataParam) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_PostDataParam.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_PostDataParam proto.InternalMessageInfo

func (m *HAR_PostDataParam) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_PostDataParam) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *HAR_PostDataParam) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *HAR_PostDataParam) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HAR_PostDataParam) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type HAR_Query struct {
	Comment              string   `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Value                string   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_Query) Reset()         { *m = HAR_Query{} }
func (m *HAR_Query) String() string { return proto.CompactTextString(m) }
func (*HAR_Query) ProtoMessage()    {}
func (*HAR_Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 15}
}
func (m *HAR_Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Query.Merge(dst, src)
}
func (m *HAR_Query) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Query) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Query.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Query proto.InternalMessageInfo

func (m *HAR_Query) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Query) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HAR_Query) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type HAR_Timings struct {
	Comment              string   `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	Blocked              int64    `protobuf:"varint,2,opt,name=blocked,proto3" json:"blocked,omitempty"`
	Connect              int64    `protobuf:"varint,3,opt,name=connect,proto3" json:"connect,omitempty"`
	Dns                  int64    `protobuf:"varint,4,opt,name=dns,proto3" json:"dns,omitempty"`
	Receive              int64    `protobuf:"varint,5,opt,name=receive,proto3" json:"receive,omitempty"`
	Send                 int64    `protobuf:"varint,6,opt,name=send,proto3" json:"send,omitempty"`
	Ssl                  int64    `protobuf:"varint,7,opt,name=ssl,proto3" json:"ssl,omitempty"`
	Wait                 int64    `protobuf:"varint,8,opt,name=wait,proto3" json:"wait,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HAR_Timings) Reset()         { *m = HAR_Timings{} }
func (m *HAR_Timings) String() string { return proto.CompactTextString(m) }
func (*HAR_Timings) ProtoMessage()    {}
func (*HAR_Timings) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_f5e2b4507b9f4518, []int{24, 16}
}
func (m *HAR_Timings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HAR_Timings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HAR_Timings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HAR_Timings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HAR_Timings.Merge(dst, src)
}
func (m *HAR_Timings) XXX_Size() int {
	return m.Size()
}
func (m *HAR_Timings) XXX_DiscardUnknown() {
	xxx_messageInfo_HAR_Timings.DiscardUnknown(m)
}

var xxx_messageInfo_HAR_Timings proto.InternalMessageInfo

func (m *HAR_Timings) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *HAR_Timings) GetBlocked() int64 {
	if m != nil {
		return m.Blocked
	}
	return 0
}

func (m *HAR_Timings) GetConnect() int64 {
	if m != nil {
		return m.Connect
	}
	return 0
}

func (m *HAR_Timings) GetDns() int64 {
	if m != nil {
		return m.Dns
	}
	return 0
}

func (m *HAR_Timings) GetReceive() int64 {
	if m != nil {
		return m.Receive
	}
	return 0
}

func (m *HAR_Timings) GetSend() int64 {
	if m != nil {
		return m.Send
	}
	return 0
}

func (m *HAR_Timings) GetSsl() int64 {
	if m != nil {
		return m.Ssl
	}
	return 0
}

func (m *HAR_Timings) GetWait() int64 {
	if m != nil {
		return m.Wait
	}
	return 0
}

func init() {
	proto.RegisterType((*Msg)(nil), "lib.Msg")
	proto.RegisterType((*RepError)(nil), "lib.RepError")
	proto.RegisterType((*DoFuzz)(nil), "lib.DoFuzz")
	proto.RegisterType((*FuzzProgress)(nil), "lib.FuzzProgress")
	proto.RegisterType((*ReqDoReset)(nil), "lib.ReqDoReset")
	proto.RegisterType((*RepResetProgress)(nil), "lib.RepResetProgress")
	proto.RegisterType((*SUTMetrics)(nil), "lib.SUTMetrics")
	proto.RegisterType((*ReqDoCall)(nil), "lib.ReqDoCall")
	proto.RegisterType((*RepCallDone)(nil), "lib.RepCallDone")
	proto.RegisterType((*RepValidateProgress)(nil), "lib.RepValidateProgress")
	proto.RegisterType((*RepCallResult)(nil), "lib.RepCallResult")
	proto.RegisterType((*UserCfg)(nil), "lib.UserCfg")
	proto.RegisterType((*UserCfg_Runtime)(nil), "lib.UserCfg.Runtime")
	proto.RegisterType((*UserCfg_Exec)(nil), "lib.UserCfg.Exec")
	proto.RegisterType((*SpecIR)(nil), "lib.SpecIR")
	proto.RegisterMapType((map[uint32]*Endpoint)(nil), "lib.SpecIR.EndpointsEntry")
	proto.RegisterType((*Schemas)(nil), "lib.Schemas")
	proto.RegisterMapType((map[uint32]*RefOrSchemaJSON)(nil), "lib.Schemas.JsonEntry")
	proto.RegisterType((*RefOrSchemaJSON)(nil), "lib.RefOrSchemaJSON")
	proto.RegisterType((*SchemaPtr)(nil), "lib.SchemaPtr")
	proto.RegisterType((*Endpoint)(nil), "lib.Endpoint")
	proto.RegisterType((*EndpointJSON)(nil), "lib.EndpointJSON")
	proto.RegisterMapType((map[uint32]uint32)(nil), "lib.EndpointJSON.OutputsEntry")
	proto.RegisterType((*ParamJSON)(nil), "lib.ParamJSON")
	proto.RegisterType((*PathPartial)(nil), "lib.PathPartial")
	proto.RegisterType((*Schema)(nil), "lib.Schema")
	proto.RegisterType((*Schema_JSON)(nil), "lib.Schema.JSON")
	proto.RegisterMapType((map[string]uint32)(nil), "lib.Schema.JSON.PropertiesEntry")
	proto.RegisterType((*Schema_JSON_AdditionalProperties)(nil), "lib.Schema.JSON.AdditionalProperties")
	proto.RegisterType((*ArrayJSON)(nil), "lib.ArrayJSON")
	proto.RegisterType((*ObjectJSON)(nil), "lib.ObjectJSON")
	proto.RegisterMapType((map[string]*ValueJSON)(nil), "lib.ObjectJSON.ValuesEntry")
	proto.RegisterType((*ValueJSON)(nil), "lib.ValueJSON")
	proto.RegisterType((*HAR)(nil), "lib.HAR")
	proto.RegisterType((*HAR_Request)(nil), "lib.HAR.Request")
	proto.RegisterType((*HAR_Response)(nil), "lib.HAR.Response")
	proto.RegisterType((*HAR_AroundRequest)(nil), "lib.HAR.AroundRequest")
	proto.RegisterType((*HAR_Browser)(nil), "lib.HAR.Browser")
	proto.RegisterType((*HAR_Cache)(nil), "lib.HAR.Cache")
	proto.RegisterType((*HAR_Content)(nil), "lib.HAR.Content")
	proto.RegisterType((*HAR_Cookie)(nil), "lib.HAR.Cookie")
	proto.RegisterType((*HAR_Creator)(nil), "lib.HAR.Creator")
	proto.RegisterType((*HAR_Entry)(nil), "lib.HAR.Entry")
	proto.RegisterType((*HAR_Header)(nil), "lib.HAR.Header")
	proto.RegisterType((*HAR_Log)(nil), "lib.HAR.Log")
	proto.RegisterType((*HAR_Page)(nil), "lib.HAR.Page")
	proto.RegisterType((*HAR_PageTimings)(nil), "lib.HAR.PageTimings")
	proto.RegisterType((*HAR_PostData)(nil), "lib.HAR.PostData")
	proto.RegisterType((*HAR_PostDataParam)(nil), "lib.HAR.PostDataParam")
	proto.RegisterType((*HAR_Query)(nil), "lib.HAR.Query")
	proto.RegisterType((*HAR_Timings)(nil), "lib.HAR.Timings")
	proto.RegisterEnum("lib.ExecKind", ExecKind_name, ExecKind_value)
	proto.RegisterEnum("lib.RepError_Culprit", RepError_Culprit_name, RepError_Culprit_value)
	proto.RegisterEnum("lib.UserCfg_Kind", UserCfg_Kind_name, UserCfg_Kind_value)
	proto.RegisterEnum("lib.EndpointJSON_Method", EndpointJSON_Method_name, EndpointJSON_Method_value)
	proto.RegisterEnum("lib.ParamJSON_Kind", ParamJSON_Kind_name, ParamJSON_Kind_value)
	proto.RegisterEnum("lib.Schema_JSON_Type", Schema_JSON_Type_name, Schema_JSON_Type_value)
	proto.RegisterEnum("lib.Schema_JSON_Format", Schema_JSON_Format_name, Schema_JSON_Format_value)
}
func (this *Msg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg)
	if !ok {
		that2, ok := that.(Msg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ts != that1.Ts {
		return false
	}
	if that1.Msg == nil {
		if this.Msg != nil {
			return false
		}
	} else if this.Msg == nil {
		return false
	} else if !this.Msg.Equal(that1.Msg) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Msg_Error) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_Error)
	if !ok {
		that2, ok := that.(Msg_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *Msg_Fuzz) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_Fuzz)
	if !ok {
		that2, ok := that.(Msg_Fuzz)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Fuzz.Equal(that1.Fuzz) {
		return false
	}
	return true
}
func (this *Msg_FuzzProgress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_FuzzProgress)
	if !ok {
		that2, ok := that.(Msg_FuzzProgress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FuzzProgress.Equal(that1.FuzzProgress) {
		return false
	}
	return true
}
func (this *Msg_Metrics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_Metrics)
	if !ok {
		that2, ok := that.(Msg_Metrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metrics.Equal(that1.Metrics) {
		return false
	}
	return true
}
func (this *Msg_DoCall) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_DoCall)
	if !ok {
		that2, ok := that.(Msg_DoCall)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DoCall.Equal(that1.DoCall) {
		return false
	}
	return true
}
func (this *Msg_CallDone) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_CallDone)
	if !ok {
		that2, ok := that.(Msg_CallDone)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CallDone.Equal(that1.CallDone) {
		return false
	}
	return true
}
func (this *Msg_ValidateProgress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_ValidateProgress)
	if !ok {
		that2, ok := that.(Msg_ValidateProgress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ValidateProgress.Equal(that1.ValidateProgress) {
		return false
	}
	return true
}
func (this *Msg_CallResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_CallResult)
	if !ok {
		that2, ok := that.(Msg_CallResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CallResult.Equal(that1.CallResult) {
		return false
	}
	return true
}
func (this *Msg_DoReset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_DoReset)
	if !ok {
		that2, ok := that.(Msg_DoReset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DoReset.Equal(that1.DoReset) {
		return false
	}
	return true
}
func (this *Msg_ResetProgress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg_ResetProgress)
	if !ok {
		that2, ok := that.(Msg_ResetProgress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ResetProgress.Equal(that1.ResetProgress) {
		return false
	}
	return true
}
func (this *RepError) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepError)
	if !ok {
		that2, ok := that.(RepError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Culprit != that1.Culprit {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DoFuzz) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DoFuzz)
	if !ok {
		that2, ok := that.(DoFuzz)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cfg.Equal(that1.Cfg) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FuzzProgress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FuzzProgress)
	if !ok {
		that2, ok := that.(FuzzProgress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Failure != that1.Failure {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.LastCallFailure != that1.LastCallFailure {
		return false
	}
	if this.LastCallSuccess != that1.LastCallSuccess {
		return false
	}
	if this.LastCheckFailure != that1.LastCheckFailure {
		return false
	}
	if this.LastCheckSuccess != that1.LastCheckSuccess {
		return false
	}
	if this.Shrinking != that1.Shrinking {
		return false
	}
	if this.TotalTestsCount != that1.TotalTestsCount {
		return false
	}
	if this.TotalCallsCount != that1.TotalCallsCount {
		return false
	}
	if this.TotalChecksCount != that1.TotalChecksCount {
		return false
	}
	if this.TestCallsCount != that1.TestCallsCount {
		return false
	}
	if this.CallChecksCount != that1.CallChecksCount {
		return false
	}
	if this.ShrinkAmount != that1.ShrinkAmount {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReqDoReset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReqDoReset)
	if !ok {
		that2, ok := that.(ReqDoReset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RepResetProgress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepResetProgress)
	if !ok {
		that2, ok := that.(RepResetProgress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Failure != that1.Failure {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.TsDiff != that1.TsDiff {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SUTMetrics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SUTMetrics)
	if !ok {
		that2, ok := that.(SUTMetrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LogOrigin != that1.LogOrigin {
		return false
	}
	if this.LogLine != that1.LogLine {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReqDoCall) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReqDoCall)
	if !ok {
		that2, ok := that.(ReqDoCall)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EID != that1.EID {
		return false
	}
	if !this.Request.Equal(that1.Request) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RepCallDone) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepCallDone)
	if !ok {
		that2, ok := that.(RepCallDone)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Failure != that1.Failure {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.TsDiff != that1.TsDiff {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if !this.Response.Equal(that1.Response) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RepValidateProgress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepValidateProgress)
	if !ok {
		that2, ok := that.(RepValidateProgress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Failure != that1.Failure {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if len(this.Details) != len(that1.Details) {
		return false
	}
	for i := range this.Details {
		if this.Details[i] != that1.Details[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RepCallResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepCallResult)
	if !ok {
		that2, ok := that.(RepCallResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Response.Equal(that1.Response) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *UserCfg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserCfg)
	if !ok {
		that2, ok := that.(UserCfg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ApiKey != that1.ApiKey {
		return false
	}
	if len(this.Usage) != len(that1.Usage) {
		return false
	}
	for i := range this.Usage {
		if this.Usage[i] != that1.Usage[i] {
			return false
		}
	}
	if !bytes.Equal(this.Seed, that1.Seed) {
		return false
	}
	if this.N != that1.N {
		return false
	}
	if len(this.EIDs) != len(that1.EIDs) {
		return false
	}
	for i := range this.EIDs {
		if this.EIDs[i] != that1.EIDs[i] {
			return false
		}
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.File != that1.File {
		return false
	}
	if !this.Runtime.Equal(that1.Runtime) {
		return false
	}
	if !this.Exec.Equal(that1.Exec) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *UserCfg_Runtime) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserCfg_Runtime)
	if !ok {
		that2, ok := that.(UserCfg_Runtime)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.FinalHost != that1.FinalHost {
		return false
	}
	if this.FinalPort != that1.FinalPort {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *UserCfg_Exec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserCfg_Exec)
	if !ok {
		that2, ok := that.(UserCfg_Exec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Start) != len(that1.Start) {
		return false
	}
	for i := range this.Start {
		if this.Start[i] != that1.Start[i] {
			return false
		}
	}
	if len(this.Reset_) != len(that1.Reset_) {
		return false
	}
	for i := range this.Reset_ {
		if this.Reset_[i] != that1.Reset_[i] {
			return false
		}
	}
	if len(this.Stop) != len(that1.Stop) {
		return false
	}
	for i := range this.Stop {
		if this.Stop[i] != that1.Stop[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SpecIR) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecIR)
	if !ok {
		that2, ok := that.(SpecIR)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Schemas.Equal(that1.Schemas) {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Schemas) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schemas)
	if !ok {
		that2, ok := that.(Schemas)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Json) != len(that1.Json) {
		return false
	}
	for i := range this.Json {
		if !this.Json[i].Equal(that1.Json[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RefOrSchemaJSON) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RefOrSchemaJSON)
	if !ok {
		that2, ok := that.(RefOrSchemaJSON)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PtrOrSchema == nil {
		if this.PtrOrSchema != nil {
			return false
		}
	} else if this.PtrOrSchema == nil {
		return false
	} else if !this.PtrOrSchema.Equal(that1.PtrOrSchema) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RefOrSchemaJSON_Ptr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RefOrSchemaJSON_Ptr)
	if !ok {
		that2, ok := that.(RefOrSchemaJSON_Ptr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ptr.Equal(that1.Ptr) {
		return false
	}
	return true
}
func (this *RefOrSchemaJSON_Schema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RefOrSchemaJSON_Schema)
	if !ok {
		that2, ok := that.(RefOrSchemaJSON_Schema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Schema.Equal(that1.Schema) {
		return false
	}
	return true
}
func (this *SchemaPtr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaPtr)
	if !ok {
		that2, ok := that.(SchemaPtr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SID != that1.SID {
		return false
	}
	if this.Ref != that1.Ref {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Endpoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Endpoint)
	if !ok {
		that2, ok := that.(Endpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Endpoint == nil {
		if this.Endpoint != nil {
			return false
		}
	} else if this.Endpoint == nil {
		return false
	} else if !this.Endpoint.Equal(that1.Endpoint) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Endpoint_Json) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Endpoint_Json)
	if !ok {
		that2, ok := that.(Endpoint_Json)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Json.Equal(that1.Json) {
		return false
	}
	return true
}
func (this *EndpointJSON) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointJSON)
	if !ok {
		that2, ok := that.(EndpointJSON)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	if len(this.PathPartials) != len(that1.PathPartials) {
		return false
	}
	for i := range this.PathPartials {
		if !this.PathPartials[i].Equal(that1.PathPartials[i]) {
			return false
		}
	}
	if len(this.Inputs) != len(that1.Inputs) {
		return false
	}
	for i := range this.Inputs {
		if !this.Inputs[i].Equal(that1.Inputs[i]) {
			return false
		}
	}
	if len(this.Outputs) != len(that1.Outputs) {
		return false
	}
	for i := range this.Outputs {
		if this.Outputs[i] != that1.Outputs[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ParamJSON) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParamJSON)
	if !ok {
		that2, ok := that.(ParamJSON)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsRequired != that1.IsRequired {
		return false
	}
	if this.SID != that1.SID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PathPartial) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathPartial)
	if !ok {
		that2, ok := that.(PathPartial)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Pp == nil {
		if this.Pp != nil {
			return false
		}
	} else if this.Pp == nil {
		return false
	} else if !this.Pp.Equal(that1.Pp) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PathPartial_Part) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathPartial_Part)
	if !ok {
		that2, ok := that.(PathPartial_Part)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Part != that1.Part {
		return false
	}
	return true
}
func (this *PathPartial_Ptr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathPartial_Ptr)
	if !ok {
		that2, ok := that.(PathPartial_Ptr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ptr != that1.Ptr {
		return false
	}
	return true
}
func (this *Schema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema)
	if !ok {
		that2, ok := that.(Schema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Schema_JSON) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema_JSON)
	if !ok {
		that2, ok := that.(Schema_JSON)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Types) != len(that1.Types) {
		return false
	}
	for i := range this.Types {
		if this.Types[i] != that1.Types[i] {
			return false
		}
	}
	if len(this.Enum) != len(that1.Enum) {
		return false
	}
	for i := range this.Enum {
		if !this.Enum[i].Equal(that1.Enum[i]) {
			return false
		}
	}
	if this.Format != that1.Format {
		return false
	}
	if this.MinLength != that1.MinLength {
		return false
	}
	if this.MaxLength != that1.MaxLength {
		return false
	}
	if this.HasMaxLength != that1.HasMaxLength {
		return false
	}
	if this.Pattern != that1.Pattern {
		return false
	}
	if this.Minimum != that1.Minimum {
		return false
	}
	if this.Maximum != that1.Maximum {
		return false
	}
	if this.HasMinimum != that1.HasMinimum {
		return false
	}
	if this.HasMaximum != that1.HasMaximum {
		return false
	}
	if this.TranslatedMultipleOf != that1.TranslatedMultipleOf {
		return false
	}
	if this.ExclusiveMinimum != that1.ExclusiveMinimum {
		return false
	}
	if this.ExclusiveMaximum != that1.ExclusiveMaximum {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if this.Items[i] != that1.Items[i] {
			return false
		}
	}
	if this.UniqueItems != that1.UniqueItems {
		return false
	}
	if this.MinItems != that1.MinItems {
		return false
	}
	if this.MaxItems != that1.MaxItems {
		return false
	}
	if this.HasMaxItems != that1.HasMaxItems {
		return false
	}
	if len(this.Properties) != len(that1.Properties) {
		return false
	}
	for i := range this.Properties {
		if this.Properties[i] != that1.Properties[i] {
			return false
		}
	}
	if len(this.Required) != len(that1.Required) {
		return false
	}
	for i := range this.Required {
		if this.Required[i] != that1.Required[i] {
			return false
		}
	}
	if this.MinProperties != that1.MinProperties {
		return false
	}
	if this.MaxProperties != that1.MaxProperties {
		return false
	}
	if this.HasMaxProperties != that1.HasMaxProperties {
		return false
	}
	if !this.AdditionalProperties.Equal(that1.AdditionalProperties) {
		return false
	}
	if this.HasAdditionalProperties != that1.HasAdditionalProperties {
		return false
	}
	if len(this.AllOf) != len(that1.AllOf) {
		return false
	}
	for i := range this.AllOf {
		if this.AllOf[i] != that1.AllOf[i] {
			return false
		}
	}
	if len(this.AnyOf) != len(that1.AnyOf) {
		return false
	}
	for i := range this.AnyOf {
		if this.AnyOf[i] != that1.AnyOf[i] {
			return false
		}
	}
	if len(this.OneOf) != len(that1.OneOf) {
		return false
	}
	for i := range this.OneOf {
		if this.OneOf[i] != that1.OneOf[i] {
			return false
		}
	}
	if this.Not != that1.Not {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Schema_JSON_AdditionalProperties) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema_JSON_AdditionalProperties)
	if !ok {
		that2, ok := that.(Schema_JSON_AdditionalProperties)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AddProps == nil {
		if this.AddProps != nil {
			return false
		}
	} else if this.AddProps == nil {
		return false
	} else if !this.AddProps.Equal(that1.AddProps) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Schema_JSON_AdditionalProperties_AlwaysSucceed) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema_JSON_AdditionalProperties_AlwaysSucceed)
	if !ok {
		that2, ok := that.(Schema_JSON_AdditionalProperties_AlwaysSucceed)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AlwaysSucceed != that1.AlwaysSucceed {
		return false
	}
	return true
}
func (this *Schema_JSON_AdditionalProperties_SID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema_JSON_AdditionalProperties_SID)
	if !ok {
		that2, ok := that.(Schema_JSON_AdditionalProperties_SID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SID != that1.SID {
		return false
	}
	return true
}
func (this *ArrayJSON) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArrayJSON)
	if !ok {
		that2, ok := that.(ArrayJSON)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !this.Values[i].Equal(that1.Values[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ObjectJSON) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectJSON)
	if !ok {
		that2, ok := that.(ObjectJSON)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !this.Values[i].Equal(that1.Values[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ValueJSON) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueJSON)
	if !ok {
		that2, ok := that.(ValueJSON)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ValueJSON_IsNull) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueJSON_IsNull)
	if !ok {
		that2, ok := that.(ValueJSON_IsNull)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsNull != that1.IsNull {
		return false
	}
	return true
}
func (this *ValueJSON_Boolean) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueJSON_Boolean)
	if !ok {
		that2, ok := that.(ValueJSON_Boolean)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Boolean != that1.Boolean {
		return false
	}
	return true
}
func (this *ValueJSON_Number) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueJSON_Number)
	if !ok {
		that2, ok := that.(ValueJSON_Number)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *ValueJSON_Text) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueJSON_Text)
	if !ok {
		that2, ok := that.(ValueJSON_Text)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	return true
}
func (this *ValueJSON_Array) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueJSON_Array)
	if !ok {
		that2, ok := that.(ValueJSON_Array)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Array.Equal(that1.Array) {
		return false
	}
	return true
}
func (this *ValueJSON_Object) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueJSON_Object)
	if !ok {
		that2, ok := that.(ValueJSON_Object)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Object.Equal(that1.Object) {
		return false
	}
	return true
}
func (this *HAR) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR)
	if !ok {
		that2, ok := that.(HAR)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Request)
	if !ok {
		that2, ok := that.(HAR_Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.BodySize != that1.BodySize {
		return false
	}
	if this.HeadersSize != that1.HeadersSize {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.Cookies) != len(that1.Cookies) {
		return false
	}
	for i := range this.Cookies {
		if !this.Cookies[i].Equal(that1.Cookies[i]) {
			return false
		}
	}
	if this.HttpVersion != that1.HttpVersion {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	if !this.PostData.Equal(that1.PostData) {
		return false
	}
	if len(this.QueryString) != len(that1.QueryString) {
		return false
	}
	for i := range this.QueryString {
		if !this.QueryString[i].Equal(that1.QueryString[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Response) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Response)
	if !ok {
		that2, ok := that.(HAR_Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.BodySize != that1.BodySize {
		return false
	}
	if this.HeadersSize != that1.HeadersSize {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.Cookies) != len(that1.Cookies) {
		return false
	}
	for i := range this.Cookies {
		if !this.Cookies[i].Equal(that1.Cookies[i]) {
			return false
		}
	}
	if this.HttpVersion != that1.HttpVersion {
		return false
	}
	if !this.Content.Equal(that1.Content) {
		return false
	}
	if this.Redirect_URL != that1.Redirect_URL {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.StatusText != that1.StatusText {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_AroundRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_AroundRequest)
	if !ok {
		that2, ok := that.(HAR_AroundRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.ETag != that1.ETag {
		return false
	}
	if this.Expires != that1.Expires {
		return false
	}
	if this.HitCount != that1.HitCount {
		return false
	}
	if this.LastAccess != that1.LastAccess {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Browser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Browser)
	if !ok {
		that2, ok := that.(HAR_Browser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Cache) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Cache)
	if !ok {
		that2, ok := that.(HAR_Cache)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if !this.AfterRequest.Equal(that1.AfterRequest) {
		return false
	}
	if !this.BeforeRequest.Equal(that1.BeforeRequest) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Content) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Content)
	if !ok {
		that2, ok := that.(HAR_Content)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Compression != that1.Compression {
		return false
	}
	if this.Encoding != that1.Encoding {
		return false
	}
	if this.MimeType != that1.MimeType {
		return false
	}
	if this.Length != that1.Length {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Cookie) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Cookie)
	if !ok {
		that2, ok := that.(HAR_Cookie)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.Expires != that1.Expires {
		return false
	}
	if this.HttpOnly != that1.HttpOnly {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Secure != that1.Secure {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Creator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Creator)
	if !ok {
		that2, ok := that.(HAR_Creator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Entry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Entry)
	if !ok {
		that2, ok := that.(HAR_Entry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if !this.Cache.Equal(that1.Cache) {
		return false
	}
	if this.Connection != that1.Connection {
		return false
	}
	if this.PageRef != that1.PageRef {
		return false
	}
	if !this.Request.Equal(that1.Request) {
		return false
	}
	if !this.Response.Equal(that1.Response) {
		return false
	}
	if this.Server_IPAddress != that1.Server_IPAddress {
		return false
	}
	if this.StartedDateTime != that1.StartedDateTime {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	if !this.Timings.Equal(that1.Timings) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Header) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Header)
	if !ok {
		that2, ok := that.(HAR_Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Log) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Log)
	if !ok {
		that2, ok := that.(HAR_Log)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if !this.Browser.Equal(that1.Browser) {
		return false
	}
	if !this.Creator.Equal(that1.Creator) {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	if len(this.Pages) != len(that1.Pages) {
		return false
	}
	for i := range this.Pages {
		if !this.Pages[i].Equal(that1.Pages[i]) {
			return false
		}
	}
	if this.Version != that1.Version {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Page) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Page)
	if !ok {
		that2, ok := that.(HAR_Page)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.PageTimings.Equal(that1.PageTimings) {
		return false
	}
	if this.StartedDateTime != that1.StartedDateTime {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_PageTimings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_PageTimings)
	if !ok {
		that2, ok := that.(HAR_PageTimings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.OnContentLoad != that1.OnContentLoad {
		return false
	}
	if this.OnLoad != that1.OnLoad {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_PostData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_PostData)
	if !ok {
		that2, ok := that.(HAR_PostData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.MimeType != that1.MimeType {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if !this.Params[i].Equal(that1.Params[i]) {
			return false
		}
	}
	if this.Text != that1.Text {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_PostDataParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_PostDataParam)
	if !ok {
		that2, ok := that.(HAR_PostDataParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.FileName != that1.FileName {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Query) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Query)
	if !ok {
		that2, ok := that.(HAR_Query)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HAR_Timings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HAR_Timings)
	if !ok {
		that2, ok := that.(HAR_Timings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.Blocked != that1.Blocked {
		return false
	}
	if this.Connect != that1.Connect {
		return false
	}
	if this.Dns != that1.Dns {
		return false
	}
	if this.Receive != that1.Receive {
		return false
	}
	if this.Send != that1.Send {
		return false
	}
	if this.Ssl != that1.Ssl {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ts != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Ts))
	}
	if m.Msg != nil {
		nn1, err := m.Msg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Msg_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Error.Size()))
		n2, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Msg_Fuzz) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Fuzz != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Fuzz.Size()))
		n3, err := m.Fuzz.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Msg_FuzzProgress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FuzzProgress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.FuzzProgress.Size()))
		n4, err := m.FuzzProgress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Msg_Metrics) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Metrics != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Metrics.Size()))
		n5, err := m.Metrics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Msg_DoCall) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DoCall != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DoCall.Size()))
		n6, err := m.DoCall.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Msg_CallDone) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CallDone != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CallDone.Size()))
		n7, err := m.CallDone.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Msg_ValidateProgress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ValidateProgress != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.ValidateProgress.Size()))
		n8, err := m.ValidateProgress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Msg_CallResult) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CallResult != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CallResult.Size()))
		n9, err := m.CallResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Msg_DoReset) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DoReset != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DoReset.Size()))
		n10, err := m.DoReset.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Msg_ResetProgress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ResetProgress != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.ResetProgress.Size()))
		n11, err := m.ResetProgress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *RepError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Culprit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Culprit))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DoFuzz) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoFuzz) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cfg != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Cfg.Size()))
		n12, err := m.Cfg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Spec.Size()))
		n13, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FuzzProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuzzProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Failure {
		dAtA[i] = 0x8
		i++
		if m.Failure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Success {
		dAtA[i] = 0x10
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastCallFailure {
		dAtA[i] = 0x18
		i++
		if m.LastCallFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastCallSuccess {
		dAtA[i] = 0x20
		i++
		if m.LastCallSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastCheckFailure {
		dAtA[i] = 0x28
		i++
		if m.LastCheckFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastCheckSuccess {
		dAtA[i] = 0x30
		i++
		if m.LastCheckSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Shrinking {
		dAtA[i] = 0x38
		i++
		if m.Shrinking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TotalTestsCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TotalTestsCount))
	}
	if m.TotalCallsCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TotalCallsCount))
	}
	if m.TotalChecksCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TotalChecksCount))
	}
	if m.TestCallsCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestCallsCount))
	}
	if m.CallChecksCount != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CallChecksCount))
	}
	if m.ShrinkAmount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.ShrinkAmount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReqDoReset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDoReset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepResetProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepResetProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Failure {
		dAtA[i] = 0x8
		i++
		if m.Failure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Success {
		dAtA[i] = 0x10
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TsDiff != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TsDiff))
	}
	if m.Kind != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SUTMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SUTMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LogOrigin) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.LogOrigin)))
		i += copy(dAtA[i:], m.LogOrigin)
	}
	if len(m.LogLine) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.LogLine)))
		i += copy(dAtA[i:], m.LogLine)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReqDoCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDoCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.EID))
	}
	if m.Request != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Request.Size()))
		n14, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepCallDone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepCallDone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Failure {
		dAtA[i] = 0x8
		i++
		if m.Failure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Success {
		dAtA[i] = 0x10
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TsDiff != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TsDiff))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.Response != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Response.Size()))
		n15, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepValidateProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepValidateProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Failure {
		dAtA[i] = 0x8
		i++
		if m.Failure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Success {
		dAtA[i] = 0x10
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Details) > 0 {
		for _, s := range m.Details {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepCallResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepCallResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Response.Size()))
		n16, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UserCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCfg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Version))
	}
	if len(m.ApiKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ApiKey)))
		i += copy(dAtA[i:], m.ApiKey)
	}
	if len(m.Usage) > 0 {
		for _, s := range m.Usage {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Seed) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Seed)))
		i += copy(dAtA[i:], m.Seed)
	}
	if m.N != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.N))
	}
	if len(m.EIDs) > 0 {
		dAtA18 := make([]byte, len(m.EIDs)*10)
		var j17 int
		for _, num := range m.EIDs {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if m.Kind != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Kind))
	}
	if len(m.File) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	if m.Runtime != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Runtime.Size()))
		n19, err := m.Runtime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Exec != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Exec.Size()))
		n20, err := m.Exec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UserCfg_Runtime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCfg_Runtime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.FinalHost) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.FinalHost)))
		i += copy(dAtA[i:], m.FinalHost)
	}
	if len(m.FinalPort) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.FinalPort)))
		i += copy(dAtA[i:], m.FinalPort)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UserCfg_Exec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCfg_Exec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		for _, s := range m.Start {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Reset_) > 0 {
		for _, s := range m.Reset_ {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Stop) > 0 {
		for _, s := range m.Stop {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SpecIR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecIR) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Schemas != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Schemas.Size()))
		n21, err := m.Schemas.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Endpoints) > 0 {
		for k := range m.Endpoints {
			dAtA[i] = 0x12
			i++
			v := m.Endpoints[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMessages(uint64(msgSize))
			}
			mapSize := 1 + sovMessages(uint64(k)) + msgSize
			i = encodeVarintMessages(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMessages(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMessages(dAtA, i, uint64(v.Size()))
				n22, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n22
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Schemas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schemas) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Json) > 0 {
		for k := range m.Json {
			dAtA[i] = 0xa
			i++
			v := m.Json[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMessages(uint64(msgSize))
			}
			mapSize := 1 + sovMessages(uint64(k)) + msgSize
			i = encodeVarintMessages(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMessages(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMessages(dAtA, i, uint64(v.Size()))
				n23, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n23
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RefOrSchemaJSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefOrSchemaJSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PtrOrSchema != nil {
		nn24, err := m.PtrOrSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RefOrSchemaJSON_Ptr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ptr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Ptr.Size()))
		n25, err := m.Ptr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *RefOrSchemaJSON_Schema) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Schema != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Schema.Size()))
		n26, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *SchemaPtr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaPtr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.SID))
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Ref)))
		i += copy(dAtA[i:], m.Ref)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Endpoint != nil {
		nn27, err := m.Endpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Endpoint_Json) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Json != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Json.Size()))
		n28, err := m.Json.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *EndpointJSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointJSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Method != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Method))
	}
	if len(m.PathPartials) > 0 {
		for _, msg := range m.PathPartials {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Inputs) > 0 {
		for _, msg := range m.Inputs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Outputs) > 0 {
		for k := range m.Outputs {
			dAtA[i] = 0x22
			i++
			v := m.Outputs[k]
			mapSize := 1 + sovMessages(uint64(k)) + 1 + sovMessages(uint64(v))
			i = encodeVarintMessages(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMessages(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintMessages(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ParamJSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamJSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsRequired {
		dAtA[i] = 0x8
		i++
		if m.IsRequired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.SID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PathPartial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathPartial) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pp != nil {
		nn29, err := m.Pp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PathPartial_Part) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Part)))
	i += copy(dAtA[i:], m.Part)
	return i, nil
}
func (m *PathPartial_Ptr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Ptr)))
	i += copy(dAtA[i:], m.Ptr)
	return i, nil
}
func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Schema_JSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema_JSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		dAtA31 := make([]byte, len(m.Types)*10)
		var j30 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	if len(m.Enum) > 0 {
		for _, msg := range m.Enum {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Format != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Format))
	}
	if m.MinLength != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.MinLength))
	}
	if m.MaxLength != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.MaxLength))
	}
	if m.HasMaxLength {
		dAtA[i] = 0x30
		i++
		if m.HasMaxLength {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minimum))))
		i += 8
	}
	if m.Maximum != 0 {
		dAtA[i] = 0x49
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Maximum))))
		i += 8
	}
	if m.HasMinimum {
		dAtA[i] = 0x50
		i++
		if m.HasMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasMaximum {
		dAtA[i] = 0x58
		i++
		if m.HasMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TranslatedMultipleOf != 0 {
		dAtA[i] = 0x61
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TranslatedMultipleOf))))
		i += 8
	}
	if m.ExclusiveMinimum {
		dAtA[i] = 0x68
		i++
		if m.ExclusiveMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExclusiveMaximum {
		dAtA[i] = 0x70
		i++
		if m.ExclusiveMaximum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Items) > 0 {
		dAtA33 := make([]byte, len(m.Items)*10)
		var j32 int
		for _, num := range m.Items {
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	if m.UniqueItems {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.UniqueItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MinItems != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.MinItems))
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.MaxItems))
	}
	if m.HasMaxItems {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.HasMaxItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Properties[k]
			mapSize := 1 + len(k) + sovMessages(uint64(len(k))) + 1 + sovMessages(uint64(v))
			i = encodeVarintMessages(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintMessages(dAtA, i, uint64(v))
		}
	}
	if len(m.Required) > 0 {
		for _, s := range m.Required {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.MinProperties != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.MinProperties))
	}
	if m.MaxProperties != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.MaxProperties))
	}
	if m.HasMaxProperties {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.HasMaxProperties {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AdditionalProperties != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.AdditionalProperties.Size()))
		n34, err := m.AdditionalProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.HasAdditionalProperties {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if m.HasAdditionalProperties {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AllOf) > 0 {
		dAtA36 := make([]byte, len(m.AllOf)*10)
		var j35 int
		for _, num := range m.AllOf {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	if len(m.AnyOf) > 0 {
		dAtA38 := make([]byte, len(m.AnyOf)*10)
		var j37 int
		for _, num := range m.AnyOf {
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	if len(m.OneOf) > 0 {
		dAtA40 := make([]byte, len(m.OneOf)*10)
		var j39 int
		for _, num := range m.OneOf {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA40[:j39])
	}
	if m.Not != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Not))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Schema_JSON_AdditionalProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema_JSON_AdditionalProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AddProps != nil {
		nn41, err := m.AddProps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn41
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Schema_JSON_AdditionalProperties_AlwaysSucceed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.AlwaysSucceed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Schema_JSON_AdditionalProperties_SID) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.SID))
	return i, nil
}
func (m *ArrayJSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArrayJSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectJSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectJSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k := range m.Values {
			dAtA[i] = 0xa
			i++
			v := m.Values[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMessages(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMessages(uint64(len(k))) + msgSize
			i = encodeVarintMessages(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMessages(dAtA, i, uint64(v.Size()))
				n42, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n42
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValueJSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueJSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn43, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn43
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValueJSON_IsNull) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	if m.IsNull {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ValueJSON_Boolean) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Boolean {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ValueJSON_Number) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Number))))
	i += 8
	return i, nil
}
func (m *ValueJSON_Text) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}
func (m *ValueJSON_Array) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Array != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Array.Size()))
		n44, err := m.Array.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *ValueJSON_Object) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Object != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Object.Size()))
		n45, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *HAR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.BodySize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.BodySize))
	}
	if m.HeadersSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.HeadersSize))
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cookies) > 0 {
		for _, msg := range m.Cookies {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HttpVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.HttpVersion)))
		i += copy(dAtA[i:], m.HttpVersion)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if m.PostData != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.PostData.Size()))
		n46, err := m.PostData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.QueryString) > 0 {
		for _, msg := range m.QueryString {
			dAtA[i] = 0x52
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.BodySize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.BodySize))
	}
	if m.HeadersSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.HeadersSize))
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cookies) > 0 {
		for _, msg := range m.Cookies {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HttpVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.HttpVersion)))
		i += copy(dAtA[i:], m.HttpVersion)
	}
	if m.Content != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Content.Size()))
		n47, err := m.Content.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.Redirect_URL) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Redirect_URL)))
		i += copy(dAtA[i:], m.Redirect_URL)
	}
	if m.Status != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Status))
	}
	if len(m.StatusText) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.StatusText)))
		i += copy(dAtA[i:], m.StatusText)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_AroundRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_AroundRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.ETag) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ETag)))
		i += copy(dAtA[i:], m.ETag)
	}
	if len(m.Expires) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Expires)))
		i += copy(dAtA[i:], m.Expires)
	}
	if m.HitCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.HitCount))
	}
	if len(m.LastAccess) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.LastAccess)))
		i += copy(dAtA[i:], m.LastAccess)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Browser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Browser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Cache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Cache) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.AfterRequest != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.AfterRequest.Size()))
		n48, err := m.AfterRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.BeforeRequest != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.BeforeRequest.Size()))
		n49, err := m.BeforeRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Content) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Content) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.Compression != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Compression))
	}
	if len(m.Encoding) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Encoding)))
		i += copy(dAtA[i:], m.Encoding)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.Length != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Length))
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Cookie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Cookie) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Domain) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	if len(m.Expires) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Expires)))
		i += copy(dAtA[i:], m.Expires)
	}
	if m.HttpOnly {
		dAtA[i] = 0x20
		i++
		if m.HttpOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Secure {
		dAtA[i] = 0x38
		i++
		if m.Secure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Creator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Creator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.Cache != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Cache.Size()))
		n50, err := m.Cache.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if len(m.Connection) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Connection)))
		i += copy(dAtA[i:], m.Connection)
	}
	if len(m.PageRef) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PageRef)))
		i += copy(dAtA[i:], m.PageRef)
	}
	if m.Request != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Request.Size()))
		n51, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.Response != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Response.Size()))
		n52, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if len(m.Server_IPAddress) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Server_IPAddress)))
		i += copy(dAtA[i:], m.Server_IPAddress)
	}
	if len(m.StartedDateTime) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.StartedDateTime)))
		i += copy(dAtA[i:], m.StartedDateTime)
	}
	if m.Time != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Time))
	}
	if m.Timings != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timings.Size()))
		n53, err := m.Timings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Header) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Log) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.Browser != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Browser.Size()))
		n54, err := m.Browser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.Creator != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Creator.Size()))
		n55, err := m.Creator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Pages) > 0 {
		for _, msg := range m.Pages {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Page) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.PageTimings != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.PageTimings.Size()))
		n56, err := m.PageTimings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if len(m.StartedDateTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.StartedDateTime)))
		i += copy(dAtA[i:], m.StartedDateTime)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_PageTimings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_PageTimings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.OnContentLoad != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.OnContentLoad))
	}
	if m.OnLoad != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.OnLoad))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_PostData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_PostData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if len(m.Params) > 0 {
		for _, msg := range m.Params {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_PostDataParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_PostDataParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Query) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Query) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HAR_Timings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HAR_Timings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.Blocked != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Blocked))
	}
	if m.Connect != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Connect))
	}
	if m.Dns != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Dns))
	}
	if m.Receive != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Receive))
	}
	if m.Send != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Send))
	}
	if m.Ssl != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Ssl))
	}
	if m.Wait != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Wait))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ts != 0 {
		n += 1 + sovMessages(uint64(m.Ts))
	}
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Msg_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_Fuzz) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fuzz != nil {
		l = m.Fuzz.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_FuzzProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FuzzProgress != nil {
		l = m.FuzzProgress.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_DoCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoCall != nil {
		l = m.DoCall.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_CallDone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallDone != nil {
		l = m.CallDone.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_ValidateProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidateProgress != nil {
		l = m.ValidateProgress.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_CallResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallResult != nil {
		l = m.CallResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_DoReset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoReset != nil {
		l = m.DoReset.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Msg_ResetProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResetProgress != nil {
		l = m.ResetProgress.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *RepError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Culprit != 0 {
		n += 1 + sovMessages(uint64(m.Culprit))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DoFuzz) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cfg != nil {
		l = m.Cfg.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FuzzProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failure {
		n += 2
	}
	if m.Success {
		n += 2
	}
	if m.LastCallFailure {
		n += 2
	}
	if m.LastCallSuccess {
		n += 2
	}
	if m.LastCheckFailure {
		n += 2
	}
	if m.LastCheckSuccess {
		n += 2
	}
	if m.Shrinking {
		n += 2
	}
	if m.TotalTestsCount != 0 {
		n += 1 + sovMessages(uint64(m.TotalTestsCount))
	}
	if m.TotalCallsCount != 0 {
		n += 1 + sovMessages(uint64(m.TotalCallsCount))
	}
	if m.TotalChecksCount != 0 {
		n += 1 + sovMessages(uint64(m.TotalChecksCount))
	}
	if m.TestCallsCount != 0 {
		n += 1 + sovMessages(uint64(m.TestCallsCount))
	}
	if m.CallChecksCount != 0 {
		n += 1 + sovMessages(uint64(m.CallChecksCount))
	}
	if m.ShrinkAmount != 0 {
		n += 1 + sovMessages(uint64(m.ShrinkAmount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqDoReset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovMessages(uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepResetProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failure {
		n += 2
	}
	if m.Success {
		n += 2
	}
	if m.TsDiff != 0 {
		n += 1 + sovMessages(uint64(m.TsDiff))
	}
	if m.Kind != 0 {
		n += 1 + sovMessages(uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SUTMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LogOrigin)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.LogLine)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqDoCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EID != 0 {
		n += 1 + sovMessages(uint64(m.EID))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepCallDone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failure {
		n += 2
	}
	if m.Success {
		n += 2
	}
	if m.TsDiff != 0 {
		n += 1 + sovMessages(uint64(m.TsDiff))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepValidateProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failure {
		n += 2
	}
	if m.Success {
		n += 2
	}
	if len(m.Details) > 0 {
		for _, s := range m.Details {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepCallResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovMessages(uint64(m.Version))
	}
	l = len(m.ApiKey)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Usage) > 0 {
		for _, s := range m.Usage {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Seed)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.N != 0 {
		n += 1 + sovMessages(uint64(m.N))
	}
	if len(m.EIDs) > 0 {
		l = 0
		for _, e := range m.EIDs {
			l += sovMessages(uint64(e))
		}
		n += 1 + sovMessages(uint64(l)) + l
	}
	if m.Kind != 0 {
		n += 1 + sovMessages(uint64(m.Kind))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Runtime != nil {
		l = m.Runtime.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Exec != nil {
		l = m.Exec.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserCfg_Runtime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.FinalHost)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.FinalPort)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserCfg_Exec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Start) > 0 {
		for _, s := range m.Start {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Reset_) > 0 {
		for _, s := range m.Reset_ {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Stop) > 0 {
		for _, s := range m.Stop {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecIR) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schemas != nil {
		l = m.Schemas.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Endpoints) > 0 {
		for k, v := range m.Endpoints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessages(uint64(l))
			}
			mapEntrySize := 1 + sovMessages(uint64(k)) + l
			n += mapEntrySize + 1 + sovMessages(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schemas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Json) > 0 {
		for k, v := range m.Json {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessages(uint64(l))
			}
			mapEntrySize := 1 + sovMessages(uint64(k)) + l
			n += mapEntrySize + 1 + sovMessages(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RefOrSchemaJSON) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PtrOrSchema != nil {
		n += m.PtrOrSchema.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RefOrSchemaJSON_Ptr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ptr != nil {
		l = m.Ptr.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *RefOrSchemaJSON_Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *SchemaPtr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SID != 0 {
		n += 1 + sovMessages(uint64(m.SID))
	}
	l = len(m.Ref)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		n += m.Endpoint.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Endpoint_Json) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Json != nil {
		l = m.Json.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *EndpointJSON) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Method != 0 {
		n += 1 + sovMessages(uint64(m.Method))
	}
	if len(m.PathPartials) > 0 {
		for _, e := range m.PathPartials {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for k, v := range m.Outputs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMessages(uint64(k)) + 1 + sovMessages(uint64(v))
			n += mapEntrySize + 1 + sovMessages(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ParamJSON) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsRequired {
		n += 2
	}
	if m.SID != 0 {
		n += 1 + sovMessages(uint64(m.SID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovMessages(uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pp != nil {
		n += m.Pp.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathPartial_Part) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Part)
	n += 1 + l + sovMessages(uint64(l))
	return n
}
func (m *PathPartial_Ptr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ptr)
	n += 1 + l + sovMessages(uint64(l))
	return n
}
func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schema_JSON) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovMessages(uint64(e))
		}
		n += 1 + sovMessages(uint64(l)) + l
	}
	if len(m.Enum) > 0 {
		for _, e := range m.Enum {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.Format != 0 {
		n += 1 + sovMessages(uint64(m.Format))
	}
	if m.MinLength != 0 {
		n += 1 + sovMessages(uint64(m.MinLength))
	}
	if m.MaxLength != 0 {
		n += 1 + sovMessages(uint64(m.MaxLength))
	}
	if m.HasMaxLength {
		n += 2
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.Maximum != 0 {
		n += 9
	}
	if m.HasMinimum {
		n += 2
	}
	if m.HasMaximum {
		n += 2
	}
	if m.TranslatedMultipleOf != 0 {
		n += 9
	}
	if m.ExclusiveMinimum {
		n += 2
	}
	if m.ExclusiveMaximum {
		n += 2
	}
	if len(m.Items) > 0 {
		l = 0
		for _, e := range m.Items {
			l += sovMessages(uint64(e))
		}
		n += 1 + sovMessages(uint64(l)) + l
	}
	if m.UniqueItems {
		n += 3
	}
	if m.MinItems != 0 {
		n += 2 + sovMessages(uint64(m.MinItems))
	}
	if m.MaxItems != 0 {
		n += 2 + sovMessages(uint64(m.MaxItems))
	}
	if m.HasMaxItems {
		n += 3
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMessages(uint64(len(k))) + 1 + sovMessages(uint64(v))
			n += mapEntrySize + 2 + sovMessages(uint64(mapEntrySize))
		}
	}
	if len(m.Required) > 0 {
		for _, s := range m.Required {
			l = len(s)
			n += 2 + l + sovMessages(uint64(l))
		}
	}
	if m.MinProperties != 0 {
		n += 2 + sovMessages(uint64(m.MinProperties))
	}
	if m.MaxProperties != 0 {
		n += 2 + sovMessages(uint64(m.MaxProperties))
	}
	if m.HasMaxProperties {
		n += 3
	}
	if m.AdditionalProperties != nil {
		l = m.AdditionalProperties.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	if m.HasAdditionalProperties {
		n += 3
	}
	if len(m.AllOf) > 0 {
		l = 0
		for _, e := range m.AllOf {
			l += sovMessages(uint64(e))
		}
		n += 2 + sovMessages(uint64(l)) + l
	}
	if len(m.AnyOf) > 0 {
		l = 0
		for _, e := range m.AnyOf {
			l += sovMessages(uint64(e))
		}
		n += 2 + sovMessages(uint64(l)) + l
	}
	if len(m.OneOf) > 0 {
		l = 0
		for _, e := range m.OneOf {
			l += sovMessages(uint64(e))
		}
		n += 2 + sovMessages(uint64(l)) + l
	}
	if m.Not != 0 {
		n += 2 + sovMessages(uint64(m.Not))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schema_JSON_AdditionalProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddProps != nil {
		n += m.AddProps.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schema_JSON_AdditionalProperties_AlwaysSucceed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Schema_JSON_AdditionalProperties_SID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMessages(uint64(m.SID))
	return n
}
func (m *ArrayJSON) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectJSON) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMessages(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMessages(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMessages(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValueJSON) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValueJSON_IsNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ValueJSON_Boolean) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ValueJSON_Number) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *ValueJSON_Text) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovMessages(uint64(l))
	return n
}
func (m *ValueJSON_Array) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Array != nil {
		l = m.Array.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *ValueJSON_Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *HAR) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.BodySize != 0 {
		n += 1 + sovMessages(uint64(m.BodySize))
	}
	if m.HeadersSize != 0 {
		n += 1 + sovMessages(uint64(m.HeadersSize))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Cookies) > 0 {
		for _, e := range m.Cookies {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.HttpVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.PostData != nil {
		l = m.PostData.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.QueryString) > 0 {
		for _, e := range m.QueryString {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.BodySize != 0 {
		n += 1 + sovMessages(uint64(m.BodySize))
	}
	if m.HeadersSize != 0 {
		n += 1 + sovMessages(uint64(m.HeadersSize))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Cookies) > 0 {
		for _, e := range m.Cookies {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.HttpVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Redirect_URL)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovMessages(uint64(m.Status))
	}
	l = len(m.StatusText)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_AroundRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ETag)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Expires)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.HitCount != 0 {
		n += 1 + sovMessages(uint64(m.HitCount))
	}
	l = len(m.LastAccess)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Browser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Cache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.AfterRequest != nil {
		l = m.AfterRequest.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.BeforeRequest != nil {
		l = m.BeforeRequest.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Content) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Compression != 0 {
		n += 1 + sovMessages(uint64(m.Compression))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovMessages(uint64(m.Length))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Cookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Expires)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.HttpOnly {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Secure {
		n += 2
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Creator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Cache != nil {
		l = m.Cache.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Connection)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.PageRef)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Server_IPAddress)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.StartedDateTime)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovMessages(uint64(m.Time))
	}
	if m.Timings != nil {
		l = m.Timings.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Browser != nil {
		l = m.Browser.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Creator != nil {
		l = m.Creator.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.PageTimings != nil {
		l = m.PageTimings.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.StartedDateTime)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_PageTimings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.OnContentLoad != 0 {
		n += 1 + sovMessages(uint64(m.OnContentLoad))
	}
	if m.OnLoad != 0 {
		n += 1 + sovMessages(uint64(m.OnLoad))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_PostData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_PostDataParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HAR_Timings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Blocked != 0 {
		n += 1 + sovMessages(uint64(m.Blocked))
	}
	if m.Connect != 0 {
		n += 1 + sovMessages(uint64(m.Connect))
	}
	if m.Dns != 0 {
		n += 1 + sovMessages(uint64(m.Dns))
	}
	if m.Receive != 0 {
		n += 1 + sovMessages(uint64(m.Receive))
	}
	if m.Send != 0 {
		n += 1 + sovMessages(uint64(m.Send))
	}
	if m.Ssl != 0 {
		n += 1 + sovMessages(uint64(m.Ssl))
	}
	if m.Wait != 0 {
		n += 1 + sovMessages(uint64(m.Wait))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_Error{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fuzz", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DoFuzz{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_Fuzz{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuzzProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FuzzProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_FuzzProgress{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SUTMetrics{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_Metrics{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoCall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReqDoCall{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_DoCall{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallDone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepCallDone{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_CallDone{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepValidateProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_ValidateProgress{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepCallResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_CallResult{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoReset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReqDoReset{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_DoReset{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepResetProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &Msg_ResetProgress{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Culprit", wireType)
			}
			m.Culprit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Culprit |= (RepError_Culprit(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoFuzz) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoFuzz: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoFuzz: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cfg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cfg == nil {
				m.Cfg = &UserCfg{}
			}
			if err := m.Cfg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SpecIR{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuzzProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FuzzProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FuzzProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCallFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastCallFailure = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCallSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastCallSuccess = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCheckFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastCheckFailure = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCheckSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastCheckSuccess = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shrinking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shrinking = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTestsCount", wireType)
			}
			m.TotalTestsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTestsCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCallsCount", wireType)
			}
			m.TotalCallsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCallsCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalChecksCount", wireType)
			}
			m.TotalChecksCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalChecksCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCallsCount", wireType)
			}
			m.TestCallsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestCallsCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallChecksCount", wireType)
			}
			m.CallChecksCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallChecksCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkAmount", wireType)
			}
			m.ShrinkAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShrinkAmount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDoReset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDoReset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDoReset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (ExecKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepResetProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepResetProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepResetProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsDiff", wireType)
			}
			m.TsDiff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsDiff |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (ExecKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SUTMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SUTMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SUTMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogOrigin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogLine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDoCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDoCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDoCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EID", wireType)
			}
			m.EID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &HAR_Request{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepCallDone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepCallDone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepCallDone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsDiff", wireType)
			}
			m.TsDiff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsDiff |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &HAR_Entry{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepValidateProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepValidateProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepValidateProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepCallResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepCallResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepCallResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &ValueJSON{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = append(m.Usage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seed = append(m.Seed[:0], dAtA[iNdEx:postIndex]...)
			if m.Seed == nil {
				m.Seed = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EIDs = append(m.EIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EIDs) == 0 {
					m.EIDs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EIDs = append(m.EIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EIDs", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (UserCfg_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Runtime == nil {
				m.Runtime = &UserCfg_Runtime{}
			}
			if err := m.Runtime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exec == nil {
				m.Exec = &UserCfg_Exec{}
			}
			if err := m.Exec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCfg_Runtime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinalHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinalPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCfg_Exec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reset_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reset_ = append(m.Reset_, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stop = append(m.Stop, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecIR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecIR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecIR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schemas == nil {
				m.Schemas = &Schemas{}
			}
			if err := m.Schemas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = make(map[uint32]*Endpoint)
			}
			var mapkey uint32
			var mapvalue *Endpoint
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessages
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMessages
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Endpoint{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessages(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessages
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Endpoints[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schemas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schemas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schemas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Json == nil {
				m.Json = make(map[uint32]*RefOrSchemaJSON)
			}
			var mapkey uint32
			var mapvalue *RefOrSchemaJSON
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessages
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMessages
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RefOrSchemaJSON{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessages(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessages
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Json[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefOrSchemaJSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefOrSchemaJSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefOrSchemaJSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ptr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaPtr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PtrOrSchema = &RefOrSchemaJSON_Ptr{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Schema_JSON{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PtrOrSchema = &RefOrSchemaJSON_Schema{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaPtr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaPtr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaPtr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			m.SID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointJSON{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Endpoint = &Endpoint_Json{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointJSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointJSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointJSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= (EndpointJSON_Method(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPartials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathPartials = append(m.PathPartials, &PathPartial{})
			if err := m.PathPartials[len(m.PathPartials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &ParamJSON{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessages(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessages
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Outputs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamJSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamJSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamJSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRequired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRequired = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			m.SID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (ParamJSON_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathPartial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathPartial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathPartial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pp = &PathPartial_Part{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ptr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pp = &PathPartial_Ptr{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema_JSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v Schema_JSON_Type
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Schema_JSON_Type(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]Schema_JSON_Type, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Schema_JSON_Type
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Schema_JSON_Type(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, &ValueJSON{})
			if err := m.Enum[len(m.Enum)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= (Schema_JSON_Format(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLength", wireType)
			}
			m.MinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLength |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLength", wireType)
			}
			m.MaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLength |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMaxLength", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMaxLength = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minimum = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maximum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Maximum = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMinimum = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMaximum = bool(v != 0)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TranslatedMultipleOf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TranslatedMultipleOf = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMinimum = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExclusiveMaximum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExclusiveMaximum = bool(v != 0)
		case 15:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Items = append(m.Items, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Items) == 0 {
					m.Items = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Items = append(m.Items, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueItems = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			m.MinItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinItems |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMaxItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMaxItems = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessages
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessages(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessages
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Required = append(m.Required, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinProperties", wireType)
			}
			m.MinProperties = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinProperties |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProperties", wireType)
			}
			m.MaxProperties = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProperties |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMaxProperties", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMaxProperties = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = &Schema_JSON_AdditionalProperties{}
			}
			if err := m.AdditionalProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasAdditionalProperties", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasAdditionalProperties = bool(v != 0)
		case 27:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllOf = append(m.AllOf, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AllOf) == 0 {
					m.AllOf = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllOf = append(m.AllOf, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllOf", wireType)
			}
		case 28:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AnyOf = append(m.AnyOf, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AnyOf) == 0 {
					m.AnyOf = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AnyOf = append(m.AnyOf, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyOf", wireType)
			}
		case 29:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OneOf = append(m.OneOf, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OneOf) == 0 {
					m.OneOf = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OneOf = append(m.OneOf, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OneOf", wireType)
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Not", wireType)
			}
			m.Not = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Not |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema_JSON_AdditionalProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdditionalProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdditionalProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysSucceed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AddProps = &Schema_JSON_AdditionalProperties_AlwaysSucceed{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddProps = &Schema_JSON_AdditionalProperties_SID{v}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArrayJSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArrayJSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArrayJSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &ValueJSON{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectJSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectJSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectJSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = make(map[string]*ValueJSON)
			}
			var mapkey string
			var mapvalue *ValueJSON
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMessages
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMessages
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMessages
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ValueJSON{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMessages(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMessages
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Values[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueJSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueJSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueJSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &ValueJSON_IsNull{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boolean", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &ValueJSON_Boolean{b}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &ValueJSON_Number{float64(math.Float64frombits(v))}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &ValueJSON_Text{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ArrayJSON{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ValueJSON_Array{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ObjectJSON{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ValueJSON_Object{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HAR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HAR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySize", wireType)
			}
			m.BodySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BodySize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadersSize", wireType)
			}
			m.HeadersSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadersSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HAR_Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookies = append(m.Cookies, &HAR_Cookie{})
			if err := m.Cookies[len(m.Cookies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PostData == nil {
				m.PostData = &HAR_PostData{}
			}
			if err := m.PostData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryString = append(m.QueryString, &HAR_Query{})
			if err := m.QueryString[len(m.QueryString)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySize", wireType)
			}
			m.BodySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BodySize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadersSize", wireType)
			}
			m.HeadersSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadersSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HAR_Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookies = append(m.Cookies, &HAR_Cookie{})
			if err := m.Cookies[len(m.Cookies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &HAR_Content{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect_URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Redirect_URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_AroundRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AroundRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AroundRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ETag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ETag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expires = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitCount", wireType)
			}
			m.HitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HitCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAccess", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastAccess = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Browser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Browser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Browser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Cache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AfterRequest == nil {
				m.AfterRequest = &HAR_AroundRequest{}
			}
			if err := m.AfterRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BeforeRequest == nil {
				m.BeforeRequest = &HAR_AroundRequest{}
			}
			if err := m.BeforeRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Content) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			m.Compression = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Compression |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Cookie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cookie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cookie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expires = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HttpOnly = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secure = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Creator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Creator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Creator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cache == nil {
				m.Cache = &HAR_Cache{}
			}
			if err := m.Cache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &HAR_Request{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &HAR_Response{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server_IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server_IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedDateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartedDateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timings == nil {
				m.Timings = &HAR_Timings{}
			}
			if err := m.Timings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Browser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Browser == nil {
				m.Browser = &HAR_Browser{}
			}
			if err := m.Browser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creator == nil {
				m.Creator = &HAR_Creator{}
			}
			if err := m.Creator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &HAR_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &HAR_Page{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageTimings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PageTimings == nil {
				m.PageTimings = &HAR_PageTimings{}
			}
			if err := m.PageTimings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedDateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartedDateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_PageTimings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageTimings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageTimings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnContentLoad", wireType)
			}
			m.OnContentLoad = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnContentLoad |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnLoad", wireType)
			}
			m.OnLoad = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnLoad |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_PostData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &HAR_PostDataParam{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_PostDataParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostDataParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostDataParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HAR_Timings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocked", wireType)
			}
			m.Blocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Blocked |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			m.Connect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Connect |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			m.Dns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dns |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receive", wireType)
			}
			m.Receive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Receive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			m.Send = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Send |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ssl", wireType)
			}
			m.Ssl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ssl |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			m.Wait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wait |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("lib/messages.proto", fileDescriptor_messages_f5e2b4507b9f4518) }

var fileDescriptor_messages_f5e2b4507b9f4518 = []byte{
	// 3591 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0x4f, 0x73, 0x5b, 0x47,
	0x72, 0x27, 0xfe, 0x03, 0x0d, 0x80, 0x7c, 0x1c, 0x51, 0x14, 0x04, 0xef, 0xca, 0x32, 0x6c, 0x6b,
	0x65, 0xda, 0x4b, 0x26, 0x92, 0xbd, 0x71, 0x79, 0xcb, 0x49, 0x28, 0x92, 0x5a, 0xd2, 0x92, 0x48,
	0xee, 0x90, 0x72, 0xaa, 0xf6, 0xf2, 0x32, 0x04, 0x06, 0xe0, 0xac, 0x1e, 0xde, 0x3c, 0xbf, 0x37,
	0x90, 0x08, 0x1d, 0xf3, 0xe7, 0x96, 0xca, 0x25, 0x95, 0xe4, 0x90, 0x4a, 0xce, 0xa9, 0xe4, 0x03,
	0xe4, 0x94, 0xf3, 0xe6, 0x94, 0xda, 0xdc, 0x73, 0xd8, 0x72, 0x55, 0x0e, 0xf9, 0x00, 0xa9, 0x5c,
	0x53, 0xdd, 0x33, 0x03, 0x3c, 0x50, 0x5c, 0xaa, 0xb2, 0xe5, 0xd3, 0x9e, 0x38, 0xdd, 0xbf, 0xdf,
	0xcc, 0xf4, 0xcc, 0xf4, 0x74, 0xf7, 0x1b, 0x10, 0x58, 0xa4, 0xce, 0xb6, 0xc6, 0x32, 0xcb, 0xc4,
	0x48, 0x66, 0x9b, 0x49, 0xaa, 0x8d, 0x66, 0xa5, 0x48, 0x9d, 0x75, 0x7f, 0x38, 0x52, 0xe6, 0x7c,
	0x72, 0xb6, 0xd9, 0xd7, 0xe3, 0xad, 0x91, 0x1e, 0xe9, 0x2d, 0xc2, 0xce, 0x26, 0x43, 0x92, 0x48,
	0xa0, 0x96, 0xed, 0xd3, 0xfb, 0xdb, 0x32, 0x94, 0x9e, 0x65, 0x23, 0xb6, 0x0c, 0x45, 0x93, 0x75,
	0x0a, 0x77, 0x0b, 0xf7, 0xcb, 0xbc, 0x68, 0x32, 0xf6, 0x21, 0x54, 0x64, 0x9a, 0xea, 0xb4, 0x53,
	0xbc, 0x5b, 0xb8, 0xdf, 0x7c, 0xd0, 0xde, 0x8c, 0xd4, 0xd9, 0x26, 0x97, 0xc9, 0x1e, 0x2a, 0xf7,
	0x97, 0xb8, 0x45, 0xd9, 0x7b, 0x50, 0x1e, 0x4e, 0x5e, 0xbf, 0xee, 0x94, 0x88, 0xd5, 0x24, 0xd6,
	0xae, 0x7e, 0x3c, 0x79, 0xfd, 0x7a, 0x7f, 0x89, 0x13, 0xc4, 0x3e, 0x87, 0x36, 0xfe, 0x0d, 0x93,
	0x54, 0x8f, 0x52, 0x99, 0x65, 0x9d, 0x32, 0x71, 0x57, 0x89, 0x8b, 0xcc, 0x63, 0x07, 0xec, 0x2f,
	0xf1, 0xd6, 0x30, 0x27, 0xb3, 0x8f, 0xa1, 0x36, 0x96, 0x26, 0x55, 0xfd, 0xac, 0x53, 0xa1, 0x3e,
	0x2b, 0xd4, 0xe7, 0xe4, 0xf9, 0xe9, 0x33, 0xab, 0xde, 0x5f, 0xe2, 0x9e, 0xc1, 0x3e, 0x82, 0xda,
	0x40, 0x87, 0x7d, 0x11, 0x45, 0x9d, 0x2a, 0x91, 0x97, 0x9d, 0xc9, 0xdf, 0xec, 0xea, 0x1d, 0x11,
	0x45, 0xfb, 0x4b, 0xbc, 0x3a, 0xa0, 0x16, 0xdb, 0x82, 0x06, 0xf2, 0xc2, 0x81, 0x8e, 0x65, 0xa7,
	0x46, 0xe4, 0xc0, 0xaf, 0x0f, 0x09, 0xbb, 0x3a, 0x96, 0xfb, 0x4b, 0xbc, 0xde, 0x77, 0x6d, 0xf6,
	0x13, 0x58, 0x7d, 0x29, 0x22, 0x35, 0x10, 0x46, 0xce, 0x97, 0x51, 0xa7, 0x8e, 0x1d, 0xdf, 0xf1,
	0x6b, 0x47, 0xc8, 0xad, 0x26, 0x78, 0x79, 0x49, 0xc7, 0x3e, 0x83, 0x26, 0xcd, 0x9c, 0xca, 0x6c,
	0x12, 0x99, 0x4e, 0x83, 0x86, 0x60, 0xf9, 0xb9, 0x39, 0x21, 0xfb, 0x4b, 0x1c, 0xfa, 0x33, 0x89,
	0x7d, 0x02, 0xf5, 0x81, 0xc6, 0x4e, 0xd2, 0x74, 0x20, 0xb7, 0x13, 0xb4, 0x38, 0x8e, 0x6a, 0xdc,
	0x89, 0x81, 0x6d, 0xb2, 0xdf, 0x87, 0x65, 0xa2, 0xce, 0x4d, 0x6d, 0x52, 0x9f, 0x9b, 0x7e, 0x1e,
	0xa2, 0xe5, 0xec, 0x6c, 0xa7, 0x79, 0xc5, 0xa3, 0x0a, 0x94, 0xc6, 0xd9, 0xa8, 0xf7, 0xa7, 0x05,
	0xa8, 0xfb, 0x03, 0x67, 0x5b, 0x50, 0xeb, 0x4f, 0xa2, 0x24, 0x55, 0x86, 0x7c, 0x64, 0x79, 0x3e,
	0x18, 0xe1, 0x9b, 0x3b, 0x16, 0xe4, 0x9e, 0xc5, 0xd6, 0xa1, 0x9a, 0x4a, 0x91, 0xe9, 0x98, 0x1c,
	0xa8, 0xc1, 0x9d, 0xd4, 0xdb, 0x84, 0x9a, 0xe3, 0xb2, 0x26, 0xd4, 0x9e, 0x1f, 0x3e, 0x39, 0x3c,
	0xfa, 0xa3, 0xc3, 0x60, 0x89, 0x01, 0x54, 0xfb, 0x91, 0x92, 0xb1, 0x09, 0x0a, 0xd8, 0xce, 0x64,
	0xfa, 0x52, 0xa6, 0x41, 0xb1, 0x77, 0x00, 0x55, 0xeb, 0x4f, 0xec, 0x0e, 0x94, 0xfa, 0xc3, 0x11,
	0x4d, 0xdf, 0x7c, 0xd0, 0xa2, 0xe9, 0x9f, 0x67, 0x32, 0xdd, 0x19, 0x8e, 0x38, 0x02, 0xec, 0x5d,
	0x28, 0x67, 0x89, 0xec, 0x3b, 0x87, 0xb5, 0xae, 0x78, 0x92, 0xc8, 0xfe, 0x01, 0xe7, 0x04, 0xf4,
	0xfe, 0xba, 0x0c, 0xad, 0xbc, 0xbf, 0xb1, 0x0e, 0xd4, 0x86, 0x42, 0x45, 0x93, 0x54, 0xd2, 0xa8,
	0x75, 0xee, 0x45, 0x44, 0xb2, 0x49, 0xbf, 0x8f, 0x7b, 0x57, 0xb4, 0x88, 0x13, 0xd9, 0x06, 0xac,
	0x46, 0x22, 0x33, 0xe4, 0x68, 0xa1, 0xef, 0x5d, 0x22, 0xce, 0x0a, 0x02, 0x78, 0x86, 0x8f, 0xdd,
	0x28, 0x0b, 0x5c, 0x3f, 0x5e, 0x79, 0x91, 0x7b, 0xe2, 0xc6, 0xfd, 0x04, 0x98, 0xe5, 0x9e, 0xcb,
	0xfe, 0x8b, 0xd9, 0xc0, 0x15, 0x22, 0x07, 0x44, 0x46, 0xc0, 0x8f, 0xbc, 0xc8, 0xf6, 0x43, 0x57,
	0x2f, 0xb1, 0xfd, 0xd8, 0xdf, 0x83, 0x46, 0x76, 0x9e, 0xaa, 0xf8, 0x85, 0x8a, 0x47, 0xe4, 0xef,
	0x75, 0x3e, 0x57, 0xa0, 0x95, 0x46, 0x1b, 0x11, 0x85, 0x46, 0x66, 0x26, 0x0b, 0xfb, 0x7a, 0x12,
	0x1b, 0x72, 0xee, 0x36, 0x5f, 0x21, 0xe0, 0x14, 0xf5, 0x3b, 0xa8, 0x9e, 0x73, 0x71, 0x49, 0x9e,
	0xdb, 0xc8, 0x71, 0x71, 0x49, 0x8e, 0xfb, 0x09, 0x30, 0xc7, 0x45, 0x5b, 0x3c, 0x19, 0x88, 0x1c,
	0x58, 0x32, 0x01, 0x96, 0x7d, 0x1f, 0x02, 0x9c, 0x7f, 0x61, 0xe0, 0x26, 0x71, 0x97, 0x51, 0x9f,
	0x1b, 0x77, 0x03, 0x56, 0x69, 0x43, 0x17, 0x86, 0x6d, 0x59, 0x1b, 0x10, 0xc8, 0x8f, 0xfa, 0x3e,
	0xb4, 0xed, 0x42, 0x43, 0x31, 0x26, 0x5e, 0x9b, 0x78, 0x2d, 0xab, 0xdc, 0x26, 0x5d, 0x6f, 0x0b,
	0x60, 0x7e, 0x91, 0x30, 0xa2, 0xbd, 0x50, 0xf1, 0xc0, 0xb9, 0xb9, 0x8d, 0x7b, 0x7b, 0x17, 0xb2,
	0xff, 0x44, 0xc5, 0x03, 0x4e, 0x50, 0xef, 0x4f, 0x0a, 0x10, 0x5c, 0xbe, 0x46, 0xbf, 0x91, 0x33,
	0xdd, 0x82, 0x9a, 0xc9, 0xc2, 0x81, 0x1a, 0x0e, 0xc9, 0x85, 0xca, 0xbc, 0x6a, 0xb2, 0x5d, 0x35,
	0x1c, 0xce, 0x8c, 0x28, 0xff, 0x7a, 0x23, 0x1e, 0x03, 0xcc, 0x03, 0x21, 0xfb, 0x3e, 0x40, 0xa4,
	0x47, 0xa1, 0x4e, 0xd5, 0x48, 0xf9, 0x2b, 0xd7, 0x88, 0xf4, 0xe8, 0x88, 0x14, 0xec, 0x36, 0xd4,
	0x11, 0x8e, 0x54, 0x6c, 0x9d, 0xb5, 0xc1, 0x6b, 0x91, 0x1e, 0x3d, 0x55, 0xb1, 0xec, 0x1d, 0x40,
	0x63, 0x16, 0x23, 0x59, 0x00, 0xa5, 0xbd, 0x83, 0x5d, 0x5a, 0x40, 0x9b, 0x63, 0x93, 0x6d, 0x40,
	0x2d, 0x95, 0xdf, 0x4c, 0x64, 0x66, 0xdc, 0xc5, 0xb2, 0x91, 0x72, 0x7f, 0x9b, 0x63, 0xf4, 0x41,
	0x3d, 0xf7, 0x84, 0xde, 0x3f, 0x14, 0xa0, 0x99, 0x0b, 0xa1, 0xdf, 0xed, 0x96, 0xcc, 0x03, 0x4a,
	0x39, 0x1f, 0x50, 0xd8, 0x06, 0xd4, 0x53, 0x99, 0x25, 0x3a, 0xce, 0xa4, 0xcb, 0x12, 0xcb, 0x33,
	0x0b, 0xf7, 0x62, 0x93, 0x4e, 0xf9, 0x0c, 0xef, 0xf5, 0xe1, 0xc6, 0x15, 0x91, 0xfa, 0x37, 0xb2,
	0xb3, 0x03, 0xb5, 0x81, 0x34, 0x42, 0x45, 0x59, 0xa7, 0x74, 0xb7, 0x84, 0x1b, 0xea, 0xc4, 0xde,
	0x8f, 0xa1, 0xbd, 0x10, 0xcb, 0x17, 0x2c, 0x2c, 0xe4, 0x2c, 0xfc, 0x5a, 0x44, 0x13, 0xf9, 0xd5,
	0xc9, 0xd1, 0x61, 0xce, 0xc2, 0xff, 0x2d, 0x41, 0xcd, 0x45, 0x35, 0x9c, 0xe2, 0xa5, 0x4c, 0x33,
	0xa5, 0x63, 0x77, 0x20, 0x5e, 0xc4, 0x4d, 0x12, 0x89, 0x0a, 0x5f, 0xc8, 0xa9, 0x8f, 0xae, 0x22,
	0x51, 0x4f, 0xe4, 0x94, 0xad, 0x41, 0x65, 0x82, 0x15, 0x81, 0xb3, 0xc9, 0x0a, 0x8c, 0x41, 0x39,
	0x93, 0xd2, 0x7a, 0x53, 0x8b, 0x53, 0x9b, 0xb5, 0xa0, 0x10, 0xd3, 0x7e, 0xb5, 0x79, 0x21, 0x46,
	0xc6, 0xde, 0xc1, 0x2e, 0x46, 0x90, 0xd2, 0xfd, 0x36, 0xa7, 0x36, 0xfb, 0xd0, 0xf9, 0x60, 0x8d,
	0x7c, 0x70, 0x35, 0x1f, 0x70, 0x37, 0xe7, 0x7e, 0x88, 0x5d, 0x87, 0x2a, 0x92, 0x14, 0x31, 0x1a,
	0x9c, 0xda, 0x6c, 0x13, 0x6a, 0xe9, 0x24, 0x36, 0x6a, 0x2c, 0x5d, 0x8a, 0x5b, 0x5b, 0xe8, 0xcd,
	0x2d, 0xc6, 0x3d, 0x09, 0xa7, 0x92, 0x17, 0xb2, 0xef, 0x72, 0xdb, 0xe2, 0x54, 0xe8, 0xf6, 0x9c,
	0xe0, 0xae, 0x86, 0x9a, 0xeb, 0x8a, 0xb3, 0x9e, 0xeb, 0xcc, 0x26, 0xa3, 0x06, 0xa7, 0x36, 0xea,
	0x12, 0x9d, 0x1a, 0xb7, 0x25, 0xd4, 0xc6, 0x7b, 0x31, 0x54, 0xb1, 0x88, 0x42, 0x62, 0x5b, 0xd7,
	0x6f, 0x90, 0x66, 0x1f, 0xbb, 0xcc, 0x60, 0xea, 0x58, 0xce, 0xc1, 0xc7, 0x3a, 0x35, 0xdd, 0xc7,
	0x50, 0xc6, 0xe9, 0x71, 0x5b, 0x33, 0x23, 0x52, 0x9c, 0x8e, 0xb6, 0x95, 0x04, 0xd4, 0xda, 0x94,
	0x5c, 0xb4, 0x5a, 0x12, 0x68, 0xb3, 0x8d, 0x4e, 0xdc, 0x09, 0x50, 0xbb, 0xd7, 0x83, 0x32, 0xee,
	0xd8, 0x62, 0xc6, 0x6b, 0x43, 0xe3, 0x28, 0x91, 0xf1, 0xf6, 0xf1, 0xc1, 0xcb, 0x87, 0x41, 0xa1,
	0xf7, 0x2f, 0x05, 0xa8, 0xda, 0x74, 0xc5, 0xee, 0x41, 0x2d, 0xeb, 0x9f, 0xcb, 0xb1, 0xc8, 0x16,
	0xb2, 0xdd, 0x89, 0xd5, 0x71, 0x0f, 0xb2, 0xcf, 0xa1, 0x21, 0xe3, 0x41, 0xa2, 0x55, 0x6c, 0x32,
	0x32, 0xa2, 0xf9, 0xa0, 0x9b, 0x4b, 0x7b, 0x9b, 0x7b, 0x1e, 0xb4, 0xf7, 0x60, 0x4e, 0xee, 0x3e,
	0x81, 0xe5, 0x45, 0x10, 0x6f, 0x3e, 0xba, 0x93, 0xbb, 0xf9, 0x2f, 0xe4, 0x94, 0xbd, 0x0f, 0x95,
	0x97, 0xe8, 0xa1, 0x0b, 0x15, 0xa0, 0xef, 0xc5, 0x2d, 0xf6, 0x45, 0xf1, 0xf3, 0x42, 0xef, 0xcf,
	0x0a, 0x50, 0x73, 0xb6, 0xb1, 0x0d, 0x28, 0xff, 0x3c, 0x23, 0x87, 0x45, 0x6b, 0xd6, 0xf3, 0x76,
	0x6f, 0x7e, 0x95, 0xe9, 0xd8, 0x5a, 0x42, 0x9c, 0xee, 0x33, 0x68, 0xcc, 0x54, 0x57, 0xcc, 0xbf,
	0xb1, 0x38, 0xff, 0x9a, 0x2b, 0x38, 0x86, 0x47, 0xa9, 0x1d, 0x90, 0x6e, 0x4e, 0xce, 0x8c, 0x14,
	0x56, 0x2e, 0xa1, 0xac, 0x07, 0xa5, 0xc4, 0xa4, 0x0b, 0x97, 0xce, 0xa2, 0xc7, 0x06, 0x6b, 0x58,
	0x04, 0xd9, 0x06, 0x54, 0xed, 0x7e, 0x2e, 0xc4, 0x37, 0x4b, 0xdb, 0xc4, 0x51, 0xb0, 0x70, 0xb4,
	0x8c, 0x47, 0x2b, 0xd0, 0x4e, 0x4c, 0x1a, 0xea, 0x34, 0xb4, 0x8a, 0xde, 0x16, 0x34, 0x66, 0x03,
	0xe2, 0x12, 0x4e, 0xe6, 0xc1, 0xf3, 0xe4, 0x60, 0x17, 0x35, 0xa9, 0x1c, 0x3a, 0x87, 0xc4, 0x66,
	0xef, 0x0f, 0xa0, 0xee, 0xb7, 0x90, 0xfd, 0x60, 0xb6, 0x57, 0x73, 0xaf, 0xf7, 0xa0, 0x9b, 0x98,
	0x08, 0x8f, 0x00, 0xea, 0xfe, 0xe8, 0x7a, 0x7f, 0x59, 0x82, 0x56, 0x9e, 0xc4, 0x7e, 0x07, 0xaa,
	0x63, 0x69, 0xce, 0xb5, 0xcf, 0x58, 0x9d, 0x37, 0xc6, 0xd9, 0x7c, 0x46, 0x38, 0x77, 0x3c, 0xf6,
	0x19, 0xb4, 0x13, 0x61, 0xce, 0xc3, 0x44, 0xa4, 0x46, 0x89, 0xc8, 0xbb, 0x8e, 0x5d, 0xf8, 0xb1,
	0x30, 0xe7, 0xc7, 0x16, 0xe0, 0xad, 0x64, 0x2e, 0x64, 0xec, 0x1e, 0x54, 0x55, 0x9c, 0x4c, 0x8c,
	0x0d, 0x78, 0x7e, 0x3f, 0x8f, 0x45, 0x2a, 0xc6, 0x74, 0x14, 0x0e, 0x65, 0x9f, 0x43, 0x4d, 0x4f,
	0x0c, 0x11, 0xcb, 0x44, 0xbc, 0xf3, 0xa6, 0x45, 0x47, 0x96, 0x60, 0xbd, 0xc1, 0xd3, 0xbb, 0x5f,
	0x40, 0x2b, 0x0f, 0x5c, 0xe1, 0x13, 0x6b, 0x79, 0x9f, 0x68, 0xe7, 0x4f, 0xff, 0x15, 0x54, 0xed,
	0x32, 0x17, 0x2f, 0x59, 0x0d, 0x4a, 0x3f, 0xd9, 0x3b, 0x0d, 0x0a, 0xac, 0x0e, 0xe5, 0xfd, 0xbd,
	0xed, 0xdd, 0xa0, 0x88, 0xad, 0xe3, 0xa3, 0x93, 0xd3, 0xa0, 0x84, 0xe0, 0xf1, 0xf3, 0xd3, 0xa0,
	0xcc, 0x1a, 0x50, 0x39, 0xde, 0x3e, 0xdd, 0xd9, 0x0f, 0x2a, 0x58, 0x7b, 0xee, 0xee, 0x3d, 0xdd,
	0x3b, 0xdd, 0x0b, 0xaa, 0x38, 0xd2, 0xce, 0xd1, 0xe1, 0xe1, 0xde, 0xce, 0x69, 0x50, 0x43, 0xe1,
	0xe8, 0xf8, 0xf4, 0xe0, 0xe8, 0xf0, 0x24, 0xa8, 0x63, 0x87, 0x53, 0xbe, 0xbd, 0xb3, 0x17, 0x34,
	0x7a, 0xbf, 0x28, 0x40, 0x63, 0xb6, 0x09, 0xec, 0x5d, 0x68, 0xaa, 0x2c, 0xc4, 0x84, 0xa8, 0x52,
	0x39, 0x70, 0xe9, 0x04, 0x54, 0xc6, 0x9d, 0xc6, 0x3b, 0x49, 0x71, 0xee, 0x24, 0x0c, 0xca, 0xb1,
	0x18, 0xfb, 0xbc, 0x4c, 0x6d, 0x74, 0x8d, 0x5c, 0xfe, 0xbf, 0xb1, 0xb8, 0xd3, 0xb9, 0xe8, 0xdb,
	0xfb, 0xea, 0xaa, 0xc8, 0x52, 0x87, 0xf2, 0x99, 0x1e, 0x4c, 0xed, 0xaa, 0xf1, 0x0c, 0x83, 0x22,
	0x5a, 0xfc, 0xcd, 0x44, 0xa6, 0xd3, 0xa0, 0x84, 0x4b, 0x3c, 0x97, 0x62, 0x20, 0xd3, 0xa0, 0x4c,
	0x65, 0xb7, 0xd6, 0x2f, 0x94, 0x0c, 0x2a, 0xbd, 0x2f, 0xa1, 0x99, 0x3b, 0x7d, 0xb6, 0x86, 0x7d,
	0x53, 0x17, 0x62, 0xd1, 0x17, 0x51, 0x62, 0xcc, 0x5e, 0xa9, 0xa2, 0x53, 0xa2, 0xf0, 0xa8, 0x0c,
	0xc5, 0x24, 0xe9, 0xfd, 0x67, 0x0b, 0xaa, 0xf6, 0x32, 0x74, 0xff, 0xa3, 0x05, 0x65, 0xda, 0x8e,
	0x8f, 0xa1, 0x62, 0xa6, 0x89, 0xcc, 0x28, 0x1e, 0xf8, 0x8f, 0x86, 0xdc, 0xdd, 0xda, 0x3c, 0x9d,
	0x26, 0x92, 0x5b, 0x0e, 0xeb, 0x41, 0x59, 0xc6, 0x93, 0xb1, 0x73, 0xc7, 0xcb, 0x39, 0x92, 0x30,
	0xb6, 0x05, 0xd5, 0xa1, 0x4e, 0xc7, 0xc2, 0xc6, 0xf2, 0xe5, 0x07, 0xb7, 0xde, 0x18, 0xf1, 0x31,
	0xc1, 0xdc, 0xd1, 0x30, 0xc2, 0x8f, 0x55, 0x1c, 0x46, 0x32, 0x1e, 0x99, 0x73, 0xda, 0xcf, 0x32,
	0x6f, 0x8c, 0x55, 0xfc, 0x94, 0x14, 0x04, 0x8b, 0x0b, 0x0f, 0x57, 0x1c, 0x2c, 0x2e, 0x1c, 0xfc,
	0x01, 0x2c, 0x9f, 0x8b, 0x2c, 0xcc, 0x51, 0x6c, 0x8d, 0xdd, 0x3a, 0x17, 0xd9, 0xb3, 0x19, 0xab,
	0x03, 0xb5, 0x44, 0x18, 0x23, 0xd3, 0x98, 0x92, 0x65, 0x83, 0x7b, 0x11, 0x91, 0xb1, 0x8a, 0xd5,
	0x78, 0x32, 0xa6, 0xfc, 0x58, 0xe0, 0x5e, 0x24, 0x44, 0x5c, 0x10, 0xd2, 0x70, 0x88, 0x15, 0xd1,
	0x85, 0x68, 0x4e, 0xd7, 0x0f, 0xac, 0x0b, 0xe1, 0x84, 0xae, 0xab, 0x27, 0xb8, 0xee, 0xcd, 0x39,
	0xc1, 0x8d, 0xf0, 0x29, 0xac, 0x9b, 0x54, 0xc4, 0x59, 0x24, 0x8c, 0x1c, 0x84, 0xe3, 0x49, 0x64,
	0x54, 0x12, 0xc9, 0x50, 0x0f, 0xa9, 0x4c, 0x2e, 0xf0, 0xb5, 0x39, 0xfa, 0xcc, 0x81, 0x47, 0x43,
	0xf6, 0x31, 0xac, 0xca, 0x8b, 0x7e, 0x34, 0xc9, 0xd4, 0x4b, 0x39, 0x9b, 0xbd, 0x6d, 0x3f, 0x29,
	0x66, 0x80, 0xb7, 0x61, 0x91, 0xec, 0x2c, 0x59, 0xbe, 0x4c, 0x76, 0xf6, 0xac, 0x41, 0x45, 0x19,
	0x39, 0xce, 0x3a, 0x2b, 0x54, 0x5e, 0x58, 0x81, 0xbd, 0x07, 0xad, 0x49, 0xac, 0xbe, 0x99, 0xc8,
	0xd0, 0x82, 0x01, 0xf5, 0x6e, 0x5a, 0xdd, 0x01, 0x51, 0xde, 0x01, 0x3c, 0x2a, 0x87, 0xaf, 0xd2,
	0xe1, 0xd4, 0xc7, 0x2a, 0x9e, 0x83, 0xe2, 0xc2, 0x81, 0xcc, 0x81, 0xe2, 0xc2, 0x82, 0x3d, 0x68,
	0xfb, 0x83, 0xb3, 0x84, 0x1b, 0x76, 0x74, 0xbb, 0x4b, 0x96, 0xf3, 0x87, 0x00, 0x49, 0xaa, 0x13,
	0x99, 0x1a, 0x25, 0xb3, 0xce, 0x1a, 0x79, 0xdd, 0xdd, 0x37, 0xfc, 0xe9, 0x78, 0x46, 0xb1, 0xd1,
	0x2a, 0xd7, 0x87, 0x75, 0xb1, 0xb2, 0x73, 0x57, 0xfd, 0x26, 0xe5, 0xfb, 0x99, 0xcc, 0x3e, 0x84,
	0x65, 0xb4, 0x3d, 0x37, 0xc3, 0x3a, 0xd9, 0xd8, 0x1e, 0xab, 0x78, 0x3e, 0x26, 0xd1, 0xc4, 0x45,
	0x9e, 0x76, 0xcb, 0xd1, 0xc4, 0x45, 0x8e, 0xf6, 0x09, 0x30, 0xbf, 0x9e, 0x1c, 0xb5, 0x63, 0x37,
	0xdc, 0x2e, 0x2a, 0xc7, 0xfe, 0x19, 0xdc, 0x14, 0x83, 0x81, 0x32, 0x4a, 0x53, 0x6d, 0x33, 0xef,
	0x70, 0x9b, 0x52, 0xcd, 0x87, 0x6f, 0x2c, 0x72, 0x7b, 0xc6, 0x9e, 0x8f, 0xc2, 0xd7, 0xc4, 0x15,
	0x5a, 0xf6, 0x05, 0xdc, 0x46, 0x4b, 0xae, 0x1e, 0xbf, 0x4b, 0x06, 0xdd, 0x3a, 0x17, 0xd9, 0x55,
	0x23, 0xb2, 0x9b, 0x50, 0xc5, 0x2f, 0x37, 0x3d, 0xec, 0xbc, 0x63, 0x3d, 0x41, 0x44, 0xd1, 0xd1,
	0x90, 0xd4, 0xf1, 0x14, 0xd5, 0xdf, 0x73, 0xea, 0x78, 0x6a, 0xd5, 0x3a, 0x26, 0xb7, 0xfd, 0xbe,
	0x55, 0xeb, 0x18, 0xfd, 0x34, 0x80, 0x52, 0xac, 0x4d, 0xe7, 0x8e, 0x8d, 0xa0, 0xb1, 0x36, 0xdd,
	0x2f, 0x61, 0xe5, 0xd2, 0x29, 0xe5, 0x53, 0x47, 0xe3, 0x2d, 0xa9, 0xa3, 0xfb, 0xc7, 0xb0, 0x76,
	0xa5, 0xb5, 0x3f, 0x80, 0x65, 0x11, 0xbd, 0x12, 0xd3, 0xcc, 0x7e, 0x60, 0xfb, 0x70, 0xbe, 0xbf,
	0xc4, 0xdb, 0x56, 0x7f, 0x62, 0xd5, 0x18, 0x13, 0x67, 0x31, 0x1d, 0x63, 0xe2, 0xc9, 0xc1, 0xee,
	0xa3, 0x26, 0x34, 0xc4, 0x60, 0x40, 0x7b, 0x93, 0xf5, 0x34, 0x94, 0x31, 0xd0, 0xbd, 0x91, 0x9a,
	0x44, 0xec, 0x82, 0x74, 0x3c, 0x89, 0xa2, 0xa0, 0x88, 0xf8, 0x99, 0xd6, 0x91, 0x14, 0x71, 0x50,
	0x42, 0x41, 0xc5, 0x46, 0x8e, 0x7c, 0x9c, 0x8e, 0x27, 0xe3, 0x33, 0x99, 0x06, 0x15, 0x0c, 0xe5,
	0x22, 0x4d, 0xc5, 0x34, 0xa8, 0xd2, 0x4b, 0x89, 0x49, 0x55, 0x3c, 0x0a, 0x6a, 0xd8, 0xd6, 0x67,
	0x3f, 0x97, 0x7d, 0x13, 0xd4, 0x7b, 0xbf, 0x2c, 0x40, 0xd5, 0x06, 0x42, 0x1c, 0xfd, 0xf0, 0xe8,
	0x70, 0xcf, 0x16, 0x9c, 0xf4, 0x82, 0x85, 0x05, 0xb4, 0x9d, 0x16, 0x45, 0x9b, 0x1b, 0xe4, 0x58,
	0xa8, 0x28, 0x28, 0xb3, 0x16, 0xd4, 0xb1, 0x52, 0xc6, 0x24, 0x14, 0x54, 0x91, 0xa2, 0x92, 0x97,
	0x9f, 0x06, 0x75, 0xd7, 0xfa, 0x51, 0xd0, 0x40, 0xb3, 0x27, 0xa9, 0x0a, 0x80, 0xad, 0x42, 0x7b,
	0x92, 0xaa, 0x30, 0x95, 0x43, 0x99, 0xca, 0xb8, 0x2f, 0x83, 0x26, 0x0e, 0x94, 0xca, 0x91, 0xbc,
	0x08, 0x56, 0xb1, 0xa9, 0x62, 0xf3, 0xf0, 0x41, 0xc0, 0x5c, 0xf3, 0x47, 0x9f, 0x06, 0x37, 0xb0,
	0x39, 0x8c, 0xb4, 0x30, 0xc1, 0x1a, 0x9a, 0x3b, 0xd0, 0x93, 0xb3, 0x48, 0x06, 0x37, 0x29, 0x61,
	0x4d, 0x8d, 0x0c, 0xd6, 0x51, 0x7b, 0xa6, 0x62, 0x91, 0x4e, 0x83, 0x5b, 0x68, 0x4b, 0x22, 0xb2,
	0xec, 0x95, 0x4e, 0x07, 0x41, 0xa7, 0xf7, 0x10, 0x1a, 0xdb, 0xb8, 0x6a, 0xca, 0x2b, 0xf7, 0xa0,
	0x4a, 0xe7, 0x97, 0xb9, 0x42, 0xf3, 0x72, 0xb2, 0x70, 0x68, 0xef, 0x2f, 0x0a, 0x00, 0x47, 0xb4,
	0x29, 0xd4, 0xed, 0xe1, 0xa5, 0x6e, 0xef, 0x50, 0xb7, 0x39, 0xc1, 0x8e, 0xe0, 0x2e, 0xba, 0xa3,
	0x76, 0x0f, 0xa0, 0x99, 0x53, 0x5f, 0xe1, 0x59, 0x1f, 0x2c, 0x16, 0xaa, 0x97, 0x6d, 0xc9, 0x15,
	0x29, 0xff, 0x5e, 0x80, 0xc6, 0x0c, 0x60, 0xb7, 0xa1, 0xa6, 0xb2, 0x10, 0x8f, 0x7e, 0xe6, 0x58,
	0x55, 0x95, 0x1d, 0x4e, 0xa2, 0x88, 0x75, 0x67, 0x8e, 0x60, 0xbf, 0x3b, 0xf7, 0x97, 0xb8, 0x57,
	0xb0, 0x8e, 0x77, 0x05, 0x4a, 0x81, 0x05, 0xec, 0x65, 0x65, 0xcc, 0xd8, 0x46, 0x5e, 0xb8, 0xef,
	0x18, 0xcc, 0xd8, 0x28, 0xb1, 0x7b, 0xce, 0x5d, 0x16, 0xbe, 0x8e, 0x67, 0x5b, 0xb9, 0xbf, 0xc4,
	0x2d, 0xcc, 0x3e, 0xf2, 0xfe, 0xe3, 0xde, 0x4f, 0x57, 0x2e, 0x6d, 0x0e, 0x4e, 0x64, 0x09, 0x8f,
	0x6a, 0x6e, 0xc5, 0xbd, 0xbf, 0xeb, 0x40, 0x69, 0x7f, 0x9b, 0x77, 0xff, 0xbb, 0x08, 0x35, 0xf7,
	0x1c, 0x80, 0x99, 0xad, 0xaf, 0xc7, 0x63, 0x19, 0xfb, 0xaf, 0x33, 0x2f, 0x62, 0xc4, 0xc6, 0xba,
	0x24, 0xcc, 0xd4, 0x6b, 0xbb, 0x59, 0x15, 0x5e, 0x47, 0xc5, 0x89, 0x7a, 0x2d, 0x31, 0x1d, 0xd8,
	0xaa, 0x24, 0xb3, 0x78, 0x89, 0xf0, 0xa6, 0xd3, 0x11, 0xe5, 0x23, 0xa8, 0x39, 0xd1, 0x55, 0x96,
	0x2b, 0xb3, 0x2f, 0xfd, 0x7d, 0xd2, 0x73, 0x8f, 0x23, 0xd5, 0xd6, 0x35, 0x59, 0xa7, 0x72, 0x89,
	0xba, 0x43, 0x7a, 0xee, 0x71, 0x9a, 0xd8, 0x98, 0x24, 0xf4, 0xdf, 0xda, 0x55, 0x32, 0xba, 0x89,
	0xba, 0xaf, 0xdd, 0xf7, 0xf6, 0xfa, 0xac, 0xc6, 0xb6, 0xf9, 0xdd, 0x57, 0xd2, 0x01, 0x94, 0x9e,
	0xf3, 0xa7, 0xee, 0xd3, 0x17, 0x9b, 0x6c, 0x13, 0x1a, 0x89, 0xce, 0x4c, 0x38, 0x10, 0x46, 0xb8,
	0x6f, 0xdf, 0xd5, 0xd9, 0xcc, 0xc7, 0x3a, 0x33, 0xbb, 0xc2, 0x08, 0x5e, 0x4f, 0x5c, 0x8b, 0xfd,
	0x2e, 0xb4, 0xa8, 0x2c, 0x0b, 0xed, 0x35, 0xee, 0x40, 0xce, 0x9d, 0xb1, 0xcb, 0x4f, 0x11, 0xe4,
	0x4d, 0xe2, 0x9c, 0x10, 0xa5, 0xfb, 0x5f, 0x45, 0xa8, 0x73, 0xf7, 0x5e, 0xf0, 0xdb, 0xb8, 0xd9,
	0x1b, 0x38, 0x5a, 0x6c, 0x70, 0x49, 0xb5, 0x4b, 0x2f, 0x4e, 0x3b, 0x56, 0xcf, 0x3d, 0x01, 0x87,
	0x4b, 0xe5, 0x40, 0xa5, 0xb2, 0x6f, 0xc2, 0xf9, 0x49, 0x34, 0xbd, 0x0e, 0x4f, 0x64, 0x1d, 0x43,
	0xa4, 0x30, 0x93, 0xcc, 0xbd, 0x53, 0x3a, 0x09, 0xab, 0x28, 0xdb, 0x0a, 0xe9, 0xce, 0x00, 0xf5,
	0x04, 0xab, 0x3a, 0x95, 0x17, 0xa6, 0xfb, 0x37, 0x05, 0x68, 0x6f, 0xa7, 0x7a, 0x12, 0x0f, 0xde,
	0xee, 0xd9, 0x37, 0xa0, 0x22, 0x43, 0x23, 0x46, 0xfe, 0xed, 0x41, 0x9e, 0x0a, 0x7a, 0xbf, 0x91,
	0x17, 0x89, 0x4a, 0x65, 0xe6, 0xdf, 0xdc, 0x9c, 0x88, 0x67, 0x73, 0xae, 0x8c, 0x7b, 0xba, 0x2c,
	0x93, 0x59, 0xf5, 0x73, 0x65, 0xec, 0x9b, 0xe5, 0xbb, 0xd0, 0xa4, 0xb7, 0x5d, 0x61, 0xdf, 0x9d,
	0x2a, 0xd6, 0x30, 0x54, 0x6d, 0x93, 0xa6, 0xfb, 0x53, 0xa8, 0x3d, 0x4a, 0xf5, 0xab, 0x4c, 0xa6,
	0xd7, 0x58, 0xe4, 0xbf, 0x2a, 0x8a, 0xb9, 0xaf, 0x8a, 0xdc, 0x83, 0x92, 0x33, 0xc8, 0x89, 0xdd,
	0xbf, 0x2f, 0x40, 0x65, 0x47, 0xf4, 0xcf, 0xaf, 0x73, 0xa8, 0x1f, 0x43, 0x5b, 0x0c, 0x8d, 0x4c,
	0xc3, 0xc5, 0xf7, 0xc0, 0xf5, 0xd9, 0xe9, 0x2c, 0x6c, 0x16, 0x6f, 0x11, 0xd9, 0x6f, 0xdd, 0x97,
	0xb0, 0x7c, 0x26, 0x87, 0x3a, 0x95, 0xb3, 0xde, 0xa5, 0x6b, 0x7b, 0xb7, 0x2d, 0xdb, 0x89, 0xdd,
	0x7f, 0x2a, 0x40, 0xcd, 0x1d, 0xfe, 0x35, 0x16, 0xde, 0x85, 0x66, 0x5f, 0x8f, 0x93, 0x54, 0x66,
	0xb4, 0x46, 0xeb, 0xf4, 0x79, 0x15, 0x16, 0x6c, 0x32, 0xee, 0xeb, 0x01, 0x5e, 0x35, 0xbb, 0x05,
	0x33, 0xd9, 0x16, 0x9b, 0x63, 0x19, 0xe2, 0xc7, 0x88, 0x7b, 0x0a, 0xaa, 0xa3, 0x82, 0x32, 0xf7,
	0x3a, 0x54, 0x73, 0xdf, 0x08, 0x15, 0xee, 0x24, 0xdc, 0x66, 0x72, 0x1f, 0xeb, 0xc7, 0xd4, 0xee,
	0xfe, 0xa2, 0x00, 0x55, 0xeb, 0xf7, 0xd7, 0xd8, 0xba, 0x8e, 0xe9, 0x6f, 0x2c, 0x66, 0x8f, 0xb5,
	0x4e, 0x7a, 0x8b, 0xd3, 0xe0, 0xd5, 0xd1, 0x71, 0x34, 0x75, 0xbf, 0x22, 0xd4, 0x51, 0x71, 0x14,
	0x47, 0xd3, 0xd9, 0x71, 0x57, 0x72, 0xc7, 0xcd, 0xec, 0xc7, 0x9f, 0xb7, 0x0d, 0xdb, 0x74, 0x1b,
	0x64, 0x7f, 0x92, 0x4a, 0xf7, 0x3b, 0x80, 0x93, 0xe6, 0xd5, 0x91, 0xbd, 0x41, 0x56, 0x40, 0x4f,
	0xdb, 0x49, 0xa5, 0x30, 0xfa, 0xbb, 0xf3, 0xb4, 0xff, 0x29, 0x42, 0xc5, 0x26, 0xd2, 0x5f, 0x3f,
	0xe2, 0x07, 0x50, 0xe9, 0xa3, 0x33, 0x2e, 0x24, 0x54, 0xba, 0xff, 0xa8, 0xe5, 0x16, 0x64, 0x77,
	0x00, 0xfa, 0x3a, 0x8e, 0x65, 0xdf, 0xcc, 0xa7, 0xc9, 0x69, 0xd8, 0x6d, 0x2c, 0x1f, 0x46, 0xe8,
	0x70, 0x43, 0x77, 0x9c, 0x35, 0x94, 0xb9, 0x1c, 0xe6, 0x1f, 0xb5, 0x2b, 0x6f, 0x79, 0xd4, 0x66,
	0x3f, 0xcc, 0xbd, 0xde, 0x56, 0x2f, 0x05, 0x74, 0x1f, 0x86, 0xe7, 0x0f, 0xb8, 0x6c, 0x03, 0x56,
	0xed, 0x6f, 0x57, 0xe1, 0xc1, 0x31, 0x16, 0xc9, 0xf4, 0xfb, 0x9b, 0xcd, 0x1a, 0x2b, 0x16, 0x38,
	0x38, 0xde, 0xb6, 0x6a, 0xe2, 0x1a, 0x91, 0xe2, 0x47, 0xda, 0xac, 0x30, 0x73, 0x07, 0xb0, 0xe2,
	0x80, 0x5d, 0x61, 0xe4, 0xa9, 0x7b, 0xf0, 0x9c, 0xbd, 0xa7, 0x96, 0x38, 0xb5, 0x71, 0x19, 0x46,
	0x8d, 0x55, 0x3c, 0xca, 0xdc, 0xcb, 0xe9, 0x7c, 0x19, 0xa7, 0x56, 0xcf, 0x3d, 0xa1, 0xfb, 0x14,
	0xaa, 0x36, 0x6c, 0xff, 0x3f, 0x4f, 0x72, 0xe6, 0x18, 0xa5, 0xbc, 0x63, 0xfc, 0xaa, 0x00, 0xa5,
	0xa7, 0x7a, 0x74, 0xcd, 0x58, 0x1b, 0x50, 0x3b, 0xb3, 0x41, 0xea, 0x8d, 0xdf, 0x0d, 0x5c, 0xf0,
	0xe2, 0x9e, 0x40, 0x11, 0xdf, 0xba, 0x99, 0x8b, 0x0a, 0xb9, 0x88, 0x6f, 0xf5, 0xdc, 0x13, 0xd8,
	0x7d, 0xa8, 0xc9, 0xd8, 0xa4, 0x98, 0x6b, 0xca, 0x97, 0x72, 0xa5, 0x7b, 0x4d, 0x72, 0x30, 0x7b,
	0x1f, 0x2a, 0x78, 0xde, 0x3e, 0x27, 0xb5, 0xe7, 0x69, 0x18, 0xbd, 0xc0, 0x62, 0x79, 0x47, 0xad,
	0x2e, 0x3a, 0xea, 0x3f, 0x17, 0xa0, 0x8c, 0xcc, 0x6b, 0xd6, 0xb8, 0x0c, 0x45, 0x35, 0x70, 0xbb,
	0x55, 0x54, 0x03, 0xf6, 0x7b, 0xd0, 0x22, 0x8f, 0xf3, 0x87, 0x52, 0xca, 0x3d, 0x5c, 0xfa, 0x89,
	0xfd, 0xc1, 0x34, 0x93, 0xb9, 0x70, 0xb5, 0x23, 0x94, 0xaf, 0x76, 0x84, 0x35, 0xa8, 0x18, 0x65,
	0x22, 0x7f, 0xd5, 0xad, 0xd0, 0x3d, 0x87, 0x66, 0x6e, 0xf4, 0x6b, 0x6c, 0xbe, 0x07, 0x2b, 0x3a,
	0x0e, 0x5d, 0xfe, 0x0c, 0x23, 0x2d, 0xec, 0x02, 0x4a, 0xbc, 0xad, 0x63, 0x17, 0x61, 0x9f, 0x6a,
	0x31, 0x60, 0xb7, 0xa0, 0xa6, 0x63, 0x8b, 0x97, 0x08, 0xaf, 0xea, 0x18, 0x81, 0xee, 0x9f, 0x17,
	0xa0, 0xee, 0x0b, 0x99, 0xeb, 0xcb, 0x8f, 0x79, 0x34, 0x2d, 0x5e, 0x8a, 0xa6, 0x9b, 0x50, 0x4d,
	0x44, 0x2a, 0xc6, 0xfe, 0x29, 0x71, 0xfd, 0x8d, 0x12, 0x89, 0x1e, 0xbb, 0xb8, 0x63, 0xcd, 0xa2,
	0x6c, 0x39, 0x17, 0x65, 0xff, 0xaa, 0x00, 0xed, 0x05, 0xf6, 0x35, 0xc6, 0xbc, 0x07, 0x2d, 0xbf,
	0xe2, 0x9c, 0x3d, 0x4d, 0xa7, 0x23, 0x93, 0xde, 0x81, 0xc6, 0x50, 0x45, 0x32, 0xcc, 0x3d, 0xc5,
	0xd5, 0x51, 0x71, 0xe8, 0x22, 0x29, 0xe9, 0xcb, 0x57, 0x5d, 0x8c, 0x4a, 0xfe, 0x62, 0x3c, 0x81,
	0x0a, 0x95, 0x6c, 0xdf, 0xc9, 0x2d, 0xfb, 0xd7, 0x02, 0xd4, 0xde, 0x7e, 0xa2, 0x1d, 0xa8, 0x9d,
	0x45, 0xba, 0xff, 0x42, 0xfa, 0x93, 0xf4, 0xa2, 0xed, 0x43, 0xf1, 0xd0, 0x9d, 0xa1, 0x17, 0xb1,
	0x70, 0x1d, 0xc4, 0xf6, 0xb7, 0xe8, 0x12, 0xc7, 0x26, 0x72, 0x53, 0xd9, 0x97, 0xea, 0xa5, 0x5d,
	0x50, 0x89, 0x7b, 0xd1, 0xfe, 0x7a, 0x14, 0x0f, 0xe8, 0x7e, 0x94, 0x38, 0xb5, 0xb1, 0x7f, 0x96,
	0x45, 0x14, 0xd7, 0x4a, 0x1c, 0x9b, 0xc8, 0x7a, 0x25, 0x94, 0xfd, 0xe1, 0xb8, 0xc4, 0xa9, 0xbd,
	0xf1, 0x14, 0xea, 0xfe, 0x47, 0xcb, 0xc5, 0x4f, 0xdf, 0x86, 0xfb, 0x3d, 0x25, 0x28, 0xd8, 0x4f,
	0xc6, 0x4c, 0x1a, 0xfb, 0x30, 0x9b, 0x19, 0x9d, 0x04, 0x25, 0x76, 0x03, 0x56, 0xb0, 0x15, 0x9a,
	0x73, 0x19, 0x87, 0x96, 0x59, 0x7e, 0xf4, 0xd9, 0x3f, 0x7e, 0x7b, 0xa7, 0xf0, 0x6f, 0xdf, 0xde,
	0x29, 0xfc, 0xf2, 0xdb, 0x3b, 0x85, 0x5f, 0x7d, 0x7b, 0xa7, 0xf0, 0xb3, 0xf7, 0x73, 0xff, 0xea,
	0xf2, 0x78, 0xf2, 0xfa, 0xf5, 0xf4, 0x99, 0x8e, 0x5f, 0xc8, 0xe9, 0x8e, 0xde, 0x1a, 0x53, 0x63,
	0x2b, 0x52, 0x67, 0x67, 0x55, 0xfa, 0x3f, 0x97, 0x87, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0x56,
	0x99, 0xa5, 0x7a, 0x31, 0x23, 0x00, 0x00,
}
